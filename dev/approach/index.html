<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling approaches · DiscreteEventsCompanion.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DiscreteEventsCompanion.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Overview</a></li><li class="current"><a class="toctext" href>Modeling approaches</a><ul class="internal"><li><a class="toctext" href="#Sampling-1">Sampling</a></li><li><a class="toctext" href="#Event-scheduling-1">Event scheduling</a></li><li><a class="toctext" href="#Process-flow-1">Process flow</a></li><li><a class="toctext" href="#Comparison-1">Comparison</a></li><li><a class="toctext" href="#Combined-approach-1">Combined approach</a></li></ul></li><li><a class="toctext" href="../timer/">Real time clocks</a></li><li><a class="toctext" href="../performance/">Performance</a></li><li><a class="toctext" href="../parallel/">Parallel simulations</a></li><li><a class="toctext" href="../benchmarks/">Benchmarks</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Modeling approaches</a></li></ul><a class="edit-page" href="https://github.com/pbayer/DiscreteEventsCompanion.jl/blob/master/docs/src/approach.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Modeling approaches</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Modeling-approaches-1" href="#Modeling-approaches-1">Modeling approaches</a></h1><blockquote><p>All models are wrong. Some are useful. (George Box)</p></blockquote><p>There are different approaches in modeling <em>discrete event systems (DES)</em> for simulation. All are limiting in some way. <code>DiscreteEvents</code> tries to provide you with a simple, yet versatile grammar for modeling. Basically <strong>events</strong> here are Julia functions or expressions, which get executed at a given time.</p><h2><a class="nav-anchor" id="Sampling-1" href="#Sampling-1">Sampling</a></h2><p>The simplest mechanism for generating discrete events in time is to have a clock <code>clk</code> executing a function <code>fun</code> periodically at a given sample rate or after a given time interval. We can use this in various ways:</p><ul><li>we can define sampling events with <code>periodic!(clk, fun, Δt)</code></li><li>we can define repeating events with <code>event!(clk, fun, every, t)</code></li><li>we can setup conditional events with <code>event!(clk, fun, cond)</code> where sampling is switched on implicitly and the condition <code>cond</code> is checked every time interval <code>Δt</code>.</li></ul><p>With sampling we can model periodic events but no stochastic event sequences, characteristic of DES. Sampling is useful for DES if we have repeated or periodic events interacting with them or if we want to check for conditions or if we want to trace or visualize the system periodically.</p><h2><a class="nav-anchor" id="Event-scheduling-1" href="#Event-scheduling-1">Event scheduling</a></h2><p>Following Cassandras<a href="#footnote-1">[1]</a> we can consider discrete event systems (DES) as stochastic timed automata <span>$(\mathcal{E},\mathcal{X},\Gamma,p,p_0,G)$</span> where</p><div>\[\begin{array}{rl}
  \mathcal{E} &amp; \textrm{countable event set} \\
  \mathcal{X} &amp; \textrm{countable state space} \\
  \Gamma(x)   &amp; \textrm{feasible or enabled events}: x \in \mathcal{X}, \Gamma(x) \subseteq \mathcal{E} \\
  p(x&#39;;x,e&#39;)  &amp; \textrm{state transition probability}: x,x&#39; \in \mathcal{X}, e&#39; \in \mathcal{E} \\
  p_0(x)      &amp; \textrm{pmf} P[X_0=x]: x \in \mathcal{X}, X_o \textrm{initial state} \\
  G_i         &amp; \textrm{stochastic clock structure}: i \in \mathcal{E}
\end{array}\]</div><p><code>DiscreteEvents.jl</code> provides the <a href="https://pbayer.github.io/DiscreteEvents.jl/dev/usage/#Clocks-1"><code>Clock</code></a> <span>$G_i$</span> and an event generating mechanism: <a href="https://pbayer.github.io/DiscreteEvents.jl/dev/usage/#Events-1"><code>event!</code></a>. Everything else can be expressed with Julia functions (or expressions).</p><p>Choi and Kang<a href="#footnote-2">[2]</a> outline three approaches to event scheduling: 1) event, 2) state and 3) activity based.</p><h3><a class="nav-anchor" id="Event-based-approach-1" href="#Event-based-approach-1">Event based approach</a></h3><p>We can simply schedule Julia functions as events, possibly triggering other events.</p><pre><code class="language-julia">using DiscreteEvents, Distributions, Random

Random.seed!(123)
ex = Exponential()

chit(c) = (print(&quot;.&quot;), event!(c, fun(chat, c), after, rand(ex)))
chat(c) = (print(&quot;:&quot;), event!(c, fun(chit, c), after, rand(ex)))

c = Clock()
chit(c)
run!(c, 10)</code></pre><p>This is useful when we don&#39;t have to care much about states.</p><h3><a class="nav-anchor" id="State-based-approach-1" href="#State-based-approach-1">State based approach</a></h3><p>Events are expressed as state transitions <span>$\mathcal{f}(x, \gamma)$</span> with <span>$x \in \mathcal{X},\ \gamma \in \Gamma(x)$</span> of finite automata. The following example models 8 servers as state machines serving a queue of jobs:</p><pre><code class="language-julia">using DiscreteEvents, Printf, Random, Distributions

const p = 0.3          # probability of finishing

abstract type 𝑋 end    # define states 𝑋
struct Idle &lt;: 𝑋 end
struct Busy &lt;: 𝑋 end

abstract type Γ end    # define events Γ
struct Load &lt;: Γ end
struct Release &lt;: Γ end

mutable struct Server  # state machine body
    id::Int
    c::Clock
    state::𝑋
    job::Int
end

ex = Exponential()
jobno = 1

queue = Vector{Int}()
done  = Vector{Int}()
Base.isready(x::Array) = !isempty(x)

# transition functions 𝒇(x, γ) (implemented with Julia&#39;s multiple dispatch)
function 𝒇(A::Server, ::Idle, ::Load)
    A.job = pop!(queue)
    A.state = Busy()
    @printf(&quot;%5.2f: server %d took job %d\n&quot;, tau(A.c), A.id, A.job)
    event!(A.c, fun(𝒇, A, A.state, Release()), after, rand(ex))
end

function 𝒇(A::Server, ::Busy, ::Release)
    if rand() &gt; p
        push!(queue, A.job)
    else
        pushfirst!(done, A.job)
        @printf(&quot;%5.2f: server %d finished job %d\n&quot;, tau(A.c), A.id, A.job)
    end
    A.job = 0
    A.state=Idle()
    event!(A.c, fun(𝒇, A, A.state, Load()), fun(isready, queue))
end

function 𝒇(A::Server, 𝑥::𝑋, γ::Γ)       # catch all
    println(stderr, &quot;$(A.name) $(A.id) undefined transition $𝑥, $γ&quot;)
end

# setup a clock and 8 servers
Random.seed!(123)
c = Clock()

A = [Server(i, c, Idle(), 0) for i ∈ 1:8]
for i ∈ shuffle(1:8)
    event!(c, fun(𝒇, A[i], A[i].state, Load()), fun(isready, queue))
end

# simulate arrivals (&quot;event-based&quot;)
event!(c, (fun(pushfirst!, queue, ()-&gt;jobno), ()-&gt;global jobno += 1), every, rand(ex))

run!(c, 10)</code></pre><pre><code class="language-none">0.01: server 4 took job 1
0.12: server 6 took job 2
0.23: server 1 took job 3
0.31: server 4 took job 1
...
9.46: server 8 took job 21
9.48: server 5 finished job 8
9.48: server 5 took job 26
9.48: server 2 finished job 23
9.48: server 2 took job 27
9.52: server 7 finished job 17
9.52: server 7 took job 28
...
&quot;run! finished with 161 clock events, 90 sample steps, simulation time: 10.0&quot;</code></pre><p>Note that we modeled the arrivals &quot;event-based&quot;.</p><h3><a class="nav-anchor" id="Activity-based-approach-1" href="#Activity-based-approach-1">Activity based approach</a></h3><p>Here events are expressed as activities. We take the <a href="https://github.com/BenLauwens/SimJulia.jl/blob/master/examples/queue_mmc.ipynb">example of a multi-server M/M/c queue</a><a href="#footnote-3">[3]</a> and implement it as a sequence of server activities:</p><pre><code class="language-julia">using DiscreteEvents, Printf, Distributions, Random

mutable struct Server
    clock::Clock
    id::Int
    input::Channel{Int}
    output::Channel{Int}
    dist::Distribution
    job::Int
end

Random.seed!(8710)   # set random number seed for reproducibility
num_customers = 10   # total number of customers generated
c = 2                # number of servers
μ = 1.0 / 2          # service rate
λ = 0.9              # arrival rate
arrival_dist = Exponential(1/λ)  # interarrival time distriubtion
service_dist = Exponential(1/μ); # service time distribution
const jobno = [1]    # job counter

# activities are functions calling each other directly or as events
load(S::Server) = event!(S.clock, fun(serve, S), fun(isready, S.input))
    # we check the availability of the input channel explicitly ↑
    # since we don&#39;t want to block.

function serve(S::Server)
    S.job = take!(S.input)
    @printf(&quot;%5.3f: server %d took job %d\n&quot;, tau(S.clock), S.id, S.job)
    event!(S.clock, (fun(finish, S)), after, rand(S.dist))
end

function finish(S::Server)
    put!(S.output, S.job)
    @printf(&quot;%5.3f: server %d finished job %d\n&quot;, tau(S.clock), S.id, S.job)
    S.job=0
    load(S)
end

# model the arrivals
function arrive(c::Clock, input::Channel, num::Int, dist::Distribution)
    @printf(&quot;%5.3f: customer %d arrived\n&quot;, tau(c), jobno[1])
    put!(input, jobno[1])
    jobno[1] += 1
    if jobno[1] ≤ num
        event!(c, fun(arrive, c, input, num, dist), after, rand(dist))
    end
end

# setup the simulation environment
clk = Clock()
input = Channel{Int}(32)  # create two channels
output = Channel{Int}(32)
jobno[1] = 1              # reset job counter

# create and start the servers and the arrival process
srv = [Server(clk,i,input,output,service_dist,0) for i ∈ 1:c]
map(s-&gt;load(s), srv)
event!(clk, fun(arrive, clk, input, num_customers, arrival_dist), after, rand(arrival_dist))

run!(clk, 20)  # run the simulation</code></pre><pre><code class="language-none">0.123: customer 1 arrived
0.130: server 1 took job 1
0.226: customer 2 arrived
0.230: server 2 took job 2
0.546: server 1 finished job 1
...
9.475: customer 9 arrived
9.530: server 2 took job 9
10.066: server 1 finished job 8
10.257: customer 10 arrived
10.260: server 1 took job 10
10.626: server 1 finished job 10
10.789: server 2 finished job 9
&quot;run! finished with 20 clock events, 1168 sample steps, simulation time: 20.0&quot;</code></pre><p>Note that the checking of the input channel in <code>load ...</code> switches on sampling implicitly (1168 sample steps).</p><h2><a class="nav-anchor" id="Process-flow-1" href="#Process-flow-1">Process flow</a></h2><p>In yet another view we look at <strong>entities</strong> (e.g. messages, customers, jobs, goods) undergoing a <em>process</em> as they flow through a DES. A process can be viewed as a sequence of events separated by time intervals. Often entities or processes share limited resources. Thus they have to wait for them to become available and then undergo a transformation (e.g. transport, treatment or service) taking some time.</p><p>This view can be expressed as <a href="https://pbayer.github.io/DiscreteEvents.jl/dev/usage/#Processes-1">process</a>es taking <code>wait!</code> and <code>delay!</code> on a <code>Clock</code> or implicitly blocking until it can <code>take!</code> something from a <code>Channel</code> or <code>put!</code> it back. Processes are functions running as asynchronous Julia tasks. They can wait or delay and are suspended and reactivated by Julia&#39;s scheduler according to background events or to the availability of resources. They don&#39;t need to handle events explicitly and keep their own data. An implementation of the M/M/c problem goes like this:</p><pre><code class="language-julia">using DiscreteEvents, Printf, Distributions, Random

Random.seed!(8710)   # set random number seed for reproducibility
num_customers = 10   # total number of customers generated
num_servers = 2      # number of servers
μ = 1.0 / 2          # service rate
λ = 0.9              # arrival rate
arrival_dist = Exponential(1/λ)  # interarrival time distriubtion
service_dist = Exponential(1/μ); # service time distribution

# describe the server process
function server(clk::Clock, id::Int, input::Channel, output::Channel, service_dist::Distribution)
    job = take!(input)
    now!(clk, ()-&gt;@printf(&quot;%5.3f: server %d serving customer %d\n&quot;, tau(clk), id, job))
    delay!(clk, rand(service_dist))
    now!(clk, ()-&gt;@printf(&quot;%5.3f: server %d finished serving %d\n&quot;, tau(clk), id, job))
    put!(output, job)
end

# model arrivals
function arrivals(clk::Clock, queue::Channel, num_customers::Int, arrival_dist::Distribution)
    for i = 1:num_customers # initialize customers
        delay!(clk, rand(arrival_dist))
        put!(queue, i)
        now!(clk, ()-&gt;@printf(&quot;%5.3f: customer %d arrived\n&quot;, tau(clk), i))
    end
end

# initialize simulation environment
clock = Clock()
input = Channel{Int}(Inf)
output = Channel{Int}(Inf)
for i in 1:num_servers
    process!(clock, Prc(i, server, i, input, output, service_dist))
end
process!(clock, Prc(0, arrivals, input, num_customers, arrival_dist), 1)
run!(clock, 20)</code></pre><pre><code class="language-none">0.123: customer 1 arrived
0.123: server 1 serving customer 1
0.226: customer 2 arrived
0.226: server 2 serving customer 2
....
9.475: customer 9 arrived
9.475: server 2 serving customer 9
10.027: server 1 finished serving 8
10.257: customer 10 arrived
10.257: server 1 serving customer 10
10.624: server 1 finished serving 10
10.734: server 2 finished serving 9
&quot;run! finished with 50 clock events, 0 sample steps, simulation time: 20.0&quot;</code></pre><p>Note that</p><ul><li>the times deviate slightly from the activity based implementation because here we don&#39;t use conditional events and therefore have no time divergence due to sampling <a href="#footnote-4">[4]</a>. We had no need to use sampling (0 sample steps) since the blocking on channels is handled by Julia internally.</li><li>Processes must transfer IO-operations with a <a href="https://pbayer.github.io/DiscreteEvents.jl/dev/usage/#DiscreteEvents.now!"><code>now!</code></a> call to the clock.</li></ul><h2><a class="nav-anchor" id="Comparison-1" href="#Comparison-1">Comparison</a></h2><p>=====</p><p>The following needs rework: </p><p>The output of the last example is different from the first three approaches because we did not shuffle (the shuffling of the processes is done by the scheduler). So if the output depends very much on the sequence of events and you need to have reproducible results, explicitly controlling for the events like in the first three examples is preferable. If you are more interested in statistical evaluation - which is often the case -, the 4th approach is appropriate.</p><p>All four approaches can be expressed in <code>DiscreteEvents.jl</code>. Process based modeling seems to be the simplest and the most intuitive approach, while the first three are more complicated. But they are also more structured and controllable , which comes in handy for more complicated examples. After all, parallel processes are often tricky to control and to debug. But you can combine the approaches and take the best from all worlds.</p><h2><a class="nav-anchor" id="Combined-approach-1" href="#Combined-approach-1">Combined approach</a></h2><p>Physical systems can be modeled as <em>continuous systems</em> (nature does not jump), <em>discrete systems</em> (nature jumps here!) or <em>hybrid systems</em> (nature jumps sometimes).</p><p>While continuous systems are the domain of differential equations, discrete and hybrid systems may be modeled easier with <code>DiscreteEvents.jl</code> by combining the <em>event-scheduling</em>, the <em>process-based</em> and the <em>continuous-sampling</em> schemes.</p><h3><a class="nav-anchor" id="A-hybrid-system-1" href="#A-hybrid-system-1">A hybrid system</a></h3><p>In a hybrid system we have continuous processes and discrete events interacting in one system. A thermostat or a house heating system is a basic example of this:</p><ul><li>Heating changes between two states: On and Off. The thermostat switches heating on if romm temperature <code>Tr</code> is greater or equal 23°C, it switches off if temperature falls below 20°C.</li><li>A room cools at a rate proportional to the difference between room temperature <code>Tr</code> and environment temperature <code>Te</code>.</li><li>It heats at a rate proportional to the temperature difference between temperature of the heating fluid <code>Th</code> and room temperature <code>Tr</code>.</li><li>The room temperature <code>Tr</code> changes proportional to the difference between heating and cooling.</li></ul><p>First we setup the physical model with some assumptions:</p><pre><code class="language-julia">using DiscreteEvents, Plots, DataFrames, Random, Distributions, LaTeXStrings

const Th = 40     # temperature of heating fluid
const R = 1e-6    # thermal resistance of room insulation
const α = 2e6     # represents thermal conductivity and capacity of the air
const β = 3e-7    # represents mass of the air and heat capacity
η = 1.0           # efficiency factor reducing R if doors or windows are open
heating = false   # initially the heating is off

Δte(t, t1, t2) = cos((t-10)*π/12) * (t2-t1)/2  # change rate of a sinusoidal Te

function Δtr(Tr, Te, heating)
    Δqc = (Tr - Te)/(R * η)             # cooling rate
    Δqh = heating ? α * (Th - Tr) : 0   # heating rate
    return β * (Δqh - Δqc)              # change of room temperature
end</code></pre><p>Δtr (generic function with 1 method)</p><p>We setup a simulation for 24 hours from 0am to 12am. We update the simulation every virtual minute.</p><pre><code class="language-julia">reset!(𝐶)                               # reset the clock
rng = MersenneTwister(122)              # set random number generator
Δt = 1//60                              # evaluate every minute
Te = 11                                 # starting values
Tr = 20
df = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])

function setTemperatures(t1=8, t2=20)   # define a sampling function
    global Te += Δte(tau(), t1, t2) * 2π/1440 + rand(rng, Normal(0, 0.1))
    global Tr += Δtr(Tr, Te, heating) * Δt
    push!(df, (tau(), Tr, Te, Int(heating)) )
end

function switch(t1=20, t2=23)           # a function simulating the thermostat
    if Tr ≥ t2
        global heating = false
        event!(fun(switch, t1, t2), @val :Tr :≤ t1)  # setup a conditional event
    elseif Tr ≤ t1
        global heating = true
        event!(fun(switch, t1, t2), @val :Tr :≥ t2)  # setup a conditional event
    end
end

periodic!(fun(setTemperatures), Δt)        # setup the sampling function
switch()                                   # start the thermostat

@time run!(𝐶, 24)                          # run the simulation</code></pre><p>0.040105 seconds (89.21 k allocations: 3.435 MiB)<br/>&quot;run! finished with 0 clock events, 1440 sample steps, simulation time: 24.0&quot;</p><pre><code class="language-julia">plot(df.t, df.tr, legend=:bottomright, label=L&quot;T_r&quot;)
plot!(df.t, df.te, label=L&quot;T_e&quot;)
plot!(df.t, df.heating, label=&quot;heating&quot;)
xlabel!(&quot;hours&quot;)
ylabel!(&quot;temperature&quot;)
title!(&quot;House heating undisturbed&quot;)</code></pre><p><img src="../examples/house_heating/output_4_0.svg" alt="svg"/></p><p>Now we have people entering the room or opening windows and thus reducing thermal resistance:</p><pre><code class="language-julia">function people()
    delay!(6 + rand(Normal(0, 0.5)))         # sleep until around 6am
    sleeptime = 22 + rand(Normal(0, 0.5))    # calculate bed time
    while tau() &lt; sleeptime
        global η = rand()                    # open door or window
        delay!(0.1 * rand(Normal(1, 0.3)))   # for some time
        global η = 1.0                       # close it again
        delay!(rand())                       # do something else
    end
end

reset!(𝐶)
rng = MersenneTwister(122)
Random.seed!(1234)
Te = 11
Tr = 20
df = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])

for i in 1:2                                 # put 2 people in the house
    process!(Prc(i, people), 1)               # run process only once
end
periodic!(fun(setTemperatures), Δt)    # setup sampling
switch()                                     # start the thermostat

@time run!(𝐶, 24)</code></pre><p>0.114938 seconds (72.52 k allocations: 2.320 MiB)<br/>&quot;run! finished with 116 clock events, 1440 sample steps, simulation time: 24.0&quot;</p><pre><code class="language-julia">plot(df.t, df.tr, legend=:bottomright, label=L&quot;T_r&quot;)
plot!(df.t, df.te, label=L&quot;T_e&quot;)
plot!(df.t, df.heating, label=&quot;heating&quot;)
xlabel!(&quot;hours&quot;)
ylabel!(&quot;temperature&quot;)
title!(&quot;House heating with people&quot;)</code></pre><p><img src="../examples/house_heating/output_7_0.svg" alt="svg"/></p><p>We have now all major schemes: events, continuous sampling and processes combined in one example.</p><p><strong>see also</strong>: the <a href="../examples/house_heating/house_heating/">full house heating example</a> for further explanations.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>Cassandras and Lafortune: <em>Introduction to Discrete Event Systems</em>, Springer, 2008, Ch. 10</p></div><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p>Choi and Kang: <em>Modeling and Simulation of Discrete-Event Systems</em>, Wiley, 2013</p></div><div class="footnote" id="footnote-3"><a href="#footnote-3"><strong>[3]</strong></a><p>see also: <a href="https://en.wikipedia.org/wiki/M/M/c_queue">M/M/c queue</a> on Wikipedia and an <a href="https://github.com/BenLauwens/SimJulia.jl/blob/master/examples/queue_mmc.ipynb">implementation in <code>SimJulia</code></a>.</p></div><div class="footnote" id="footnote-4"><a href="#footnote-4"><strong>[4]</strong></a><p>the load activity in the activity based example uses a conditional event and  switches on sampling: the condition is checked periodically. But this introduces a time divergence into the simulation.</p></div><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Overview</span></a><a class="next" href="../timer/"><span class="direction">Next</span><span class="title">Real time clocks</span></a></footer></article></body></html>
