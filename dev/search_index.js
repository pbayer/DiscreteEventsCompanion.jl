var documenterSearchIndex = {"docs":
[{"location":"actors/#Actors","page":"Actors","title":"Actors","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"DES under investigation, models and simulations tend to get bigger and more complex. Likewise we want to use the available computing power of parallel and distributed systems. Actors are a way to model larger and more complex systems and to use the available computing power.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors are a more powerful computational agent than sequential processes ......  in the context of parallel systems, the degree to which a computation can be distributed over its lifetime is an important consideration. Creation of new actors provides the ability to abstractly increase the distributivity of the computation as it evolves. [1]","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"DiscreteEvents introduces actors to represent entities in DES and to distribute those entities over parallel cores of modern computers.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actor systems and actors have the following basic characteristics:Communication via direct asynchronous messaging: ...\nState machines: Actor support finite state machines. When an actor transitions to some expected state, it can modify its behavior in preparation for future messages. By becoming another kind of message handler, the actor implements a finite state machine.\nShare nothing: Actors do not share their mutable state ...\nLock-free concurrency: ... actors never need to attempt to lock their state before reacting to a message. ...\nParallelism: ... Parallelism with the Actor model tends to fit well when one higher-level actor can dispatch tasks across several subordinate actors, perhaps even in a complex task processing hierarchy.\nActors come in systems: ... [2]","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors integrate so well into an event framework because they are message driven. Messages are built on events since they signal that an event has happened. Therefore actors are more reactive to events than sequential processes. Furthermore actor systems allow to represent and compose DES in a new way. They can","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"represent hierarchy (e.g. UML state machines, different system levels ...),\nmodel structural changes in systems (e.g. making more servers available if load gets too high),","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"note: Minimal actor support\nDiscreteEvents now has minimal actor support. For explorations into actors we use YAActL.","category":"page"},{"location":"actors/#Dynamical-state-machines","page":"Actors","title":"Dynamical state machines","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors have their behaviors described by functions. They can change those functions with become. Thus they assume a new state and act as state machines:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"using YAActL\n\nfunction idle(s::Server, ::Arrive)\n    if isready(s.input)\n        s.job = take!(s.input)\n        become(busy, s)\n        get(s.clk, Finish(), after, rand(s.d))\n        ...\n    end\nend\nbusy(s::Server, ::Message) = nothing  # this is a default transition\nfunction busy(s::Server, ::Finish)\n    become(idle, s)\n    put!(s.output, s.job)\n    ...\nend","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"If the actor starts, it assumes his initial idle behavior. It delivers a link (a message channel) for sending messages to it. When it gets an Arrive() message, it checks for a job and eventually takes it and becomes busy ...","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"lnk = Link[]\nfor i in 1:num_servers          # setup servers\n    s = Server(i, clock, input, output, 0, service_dist)\n    push!(lnk, Actor(idle, s))  # start actors\nend","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"We then can command the actors over the lnk array. For the full example see M/M/c queue with Actors.","category":"page"},{"location":"actors/#Composition","page":"Actors","title":"Composition","text":"","category":"section"},{"location":"actors/#Actors-in-parallel","page":"Actors","title":"Actors in parallel","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"[1]: Gul Agha: Actors, A Model of Concurrent Computation in Distributed Systems.- 1986, MIT Press, 9","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[2]: Vaughn Vernon, Reactive Messaging Patterns with the Actor Model.- 2016, Pearson, 14f","category":"page"},{"location":"examples/examples/#Examples","page":"Overview","title":"Examples","text":"","category":"section"},{"location":"examples/examples/","page":"Overview","title":"Overview","text":"The examples should show how to use DiscreteEvents and how to employ and combine different approaches to modeling and simulation.","category":"page"},{"location":"examples/examples/","page":"Overview","title":"Overview","text":"Table tennis: a state-based simulation,\nSingle server: an activity-based simulation of a single server,\nM/M/c queue (activity): an activity based simulation of an M/M/c queue,\nM/M/c queue (processes): process based simulation of the M/M/c queue,\nM/M/c queue (state machine): a finite state machine of it,\nM/M/c queue (actor): an actor implementation with YAActL,\nHouse heating: a simulation of a hybrid system, combining three schemes: events, continuous sampling and processes.\nPost office: a process-based simulation of a post-office,\nGoldratt's dice game: a simulation of assembly lines, illustrating what can be done with multiple simulations and parameter variation on parallel threads,","category":"page"},{"location":"examples/examples/","page":"Overview","title":"Overview","text":"Working with the examples ‚Äì If you would like to play with the examples:","category":"page"},{"location":"examples/examples/","page":"Overview","title":"Overview","text":"Jupyter notebooks are here in the repo,\nJulia program files are here in the repo.","category":"page"},{"location":"examples/queue_mmc_sm/#M/M/c-with-State-Machines","page":"M/M/c State Machines","title":"M/M/c with State Machines","text":"","category":"section"},{"location":"examples/queue_mmc_sm/","page":"M/M/c State Machines","title":"M/M/c State Machines","text":"Here we implement a simple state machine as an actor. As  before we define first states and events and a state machine body:","category":"page"},{"location":"examples/queue_mmc_sm/","page":"M/M/c State Machines","title":"M/M/c State Machines","text":"using DiscreteEvents, Printf, Distributions, Random\n\nabstract type ùëã end    # define states\nstruct Idle <: ùëã end\nstruct Busy <: ùëã end\n\nabstract type ùê∏ end    # events\nstruct Arrive <: ùê∏ end\nstruct Finish <: ùê∏ end\n\nmutable struct Server  # state machine body\n    id::Int\n    clk::Clock\n    com::Channel       # this is the actor's communication channel\n    input::Channel\n    output::Channel\n    state::ùëã\n    job::Int\n    d::Distribution\nend","category":"page"},{"location":"examples/queue_mmc_sm/","page":"M/M/c State Machines","title":"M/M/c State Machines","text":"Then we implement the transition function and the actor loop running it:","category":"page"},{"location":"examples/queue_mmc_sm/","page":"M/M/c State Machines","title":"M/M/c State Machines","text":"act!(::Server, ::ùëã, ::ùê∏) = nothing   # a default transition\nfunction act!(s::Server, ::Idle, ::Arrive)\n    if isready(s.input)\n        s.job = take!(s.input)\n        s.state = Busy()\n        event!(s.clk, (fun(put!, s.com, Finish()), yield), after, rand(s.d))\n        print(s.clk, @sprintf(\"%5.3f: server %d serving customer %d\\n\", tau(s.clk), s.id, s.job))\n    end\nend\nfunction act!(s::Server, ::Busy, ::Finish)\n    s.state = Idle()\n    put!(s.output, s.job)\n    print(s.clk, @sprintf(\"%5.3f: server %d finished serving %d\\n\", tau(s.clk), s.id, s.job))\nend\nfunction act!(s::Server)  # actor loop, take something\n    while true            # from the com channel and act! on it\n        act!(s, s.state, take!(s.com))\n    end\nend","category":"page"},{"location":"examples/queue_mmc_sm/","page":"M/M/c State Machines","title":"M/M/c State Machines","text":"We need also our arrival process. It communicates arrivals over the servers' com channels.","category":"page"},{"location":"examples/queue_mmc_sm/","page":"M/M/c State Machines","title":"M/M/c State Machines","text":"function arrivals(clk::Clock, queue::Channel, srv::Vector{Server}, N::Int, M‚ÇÅ::Distribution)\n    for i = 1:N # initialize customers\n        delay!(clk, rand(M‚ÇÅ))\n        put!(queue, i)\n        print(clk, @sprintf(\"%5.3f: customer %d arrived\\n\", tau(clk), i))\n        map(s->put!(s.com,Arrive()), srv) # notify the servers\n    end\nend","category":"page"},{"location":"examples/queue_mmc_sm/","page":"M/M/c State Machines","title":"M/M/c State Machines","text":"Then we setup our global constants, the simulation environment, the actors and the arrivals process and run:","category":"page"},{"location":"examples/queue_mmc_sm/","page":"M/M/c State Machines","title":"M/M/c State Machines","text":"Random.seed!(8710)          # set random number seed for reproducibility\nconst N = 10                # total number of customers\nconst c = 2                 # number of servers\nconst Œº = 1.0 / c           # service rate\nconst Œª = 0.9               # arrival rate\nconst M‚ÇÅ = Exponential(1/Œª) # interarrival time distribution\nconst M‚ÇÇ = Exponential(1/Œº) # service time distribution\n\n# initialize simulation environment\nclock = Clock()\ninput = Channel{Int}(Inf)\noutput = Channel{Int}(Inf)\nfor i in 1:c   # start actors\n    push!(srv, Server(i, clock, Channel{ùê∏}(32), input, output, Idle(), 0, M‚ÇÇ))\n    push!(t, @task act!(srv[i]))\n    yield(t[i])\nend\nprocess!(clock, Prc(0, arrivals, input, srv, num_customers, arrival_dist), 1)\n\nrun!(clock, 20)","category":"page"},{"location":"examples/queue_mmc_sm/","page":"M/M/c State Machines","title":"M/M/c State Machines","text":"Then we get our usual output:","category":"page"},{"location":"examples/queue_mmc_sm/","page":"M/M/c State Machines","title":"M/M/c State Machines","text":"0.123: customer 1 arrived\n0.123: server 1 serving customer 1\n0.226: customer 2 arrived\n0.226: server 2 serving customer 2\n0.539: server 1 finished serving 1\n0.667: server 2 finished serving 2\n2.135: customer 3 arrived\n....\n10.027: server 1 finished serving 8\n10.257: customer 10 arrived\n10.257: server 1 serving customer 10\n10.624: server 1 finished serving 10\n10.734: server 2 finished serving 9\n\"run! finished with 50 clock events, 0 sample steps, simulation time: 20.0\"","category":"page"},{"location":"hybrid/#A-hybrid-system","page":"A hybrid system","title":"A hybrid system","text":"","category":"section"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"In a hybrid system we have continuous processes and discrete events interacting in one system. A thermostat or a house heating system is a basic example of this:","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"Heating changes between two states: On and Off. The thermostat switches heating on if romm temperature Tr is greater or equal 23¬∞C, it switches off if temperature falls below 20¬∞C.\nA room cools at a rate proportional to the difference between room temperature Tr and environment temperature Te.\nIt heats at a rate proportional to the temperature difference between temperature of the heating fluid Th and room temperature Tr.\nThe room temperature Tr changes proportional to the difference between heating and cooling.","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"First we setup the physical model with some assumptions:","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"using DiscreteEvents, Plots, DataFrames, Random, Distributions, LaTeXStrings\n\nconst Th = 40     # temperature of heating fluid\nconst R = 1e-6    # thermal resistance of room insulation\nconst Œ± = 2e6     # represents thermal conductivity and capacity of the air\nconst Œ≤ = 3e-7    # represents mass of the air and heat capacity\nŒ∑ = 1.0           # efficiency factor reducing R if doors or windows are open\nheating = false   # initially the heating is off\n\nŒîte(t, t1, t2) = cos((t-10)*œÄ/12) * (t2-t1)/2  # change rate of a sinusoidal Te\n\nfunction Œîtr(Tr, Te, heating)\n    Œîqc = (Tr - Te)/(R * Œ∑)             # cooling rate\n    Œîqh = heating ? Œ± * (Th - Tr) : 0   # heating rate\n    return Œ≤ * (Œîqh - Œîqc)              # change of room temperature\nend","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"Œîtr (generic function with 1 method)","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"We setup a simulation for 24 hours from 0am to 12am. We update the simulation every virtual minute.","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"reset!(ùê∂)                               # reset the clock\nrng = MersenneTwister(122)              # set random number generator\nŒît = 1//60                              # evaluate every minute\nTe = 11                                 # starting values\nTr = 20\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfunction setTemperatures(t1=8, t2=20)   # define a sampling function\n    global Te += Œîte(tau(), t1, t2) * 2œÄ/1440 + rand(rng, Normal(0, 0.1))\n    global Tr += Œîtr(Tr, Te, heating) * Œît\n    push!(df, (tau(), Tr, Te, Int(heating)) )\nend\n\nfunction switch(t1=20, t2=23)           # a function simulating the thermostat\n    if Tr ‚â• t2\n        global heating = false\n        event!(fun(switch, t1, t2), @val :Tr :‚â§ t1)  # setup a conditional event\n    elseif Tr ‚â§ t1\n        global heating = true\n        event!(fun(switch, t1, t2), @val :Tr :‚â• t2)  # setup a conditional event\n    end\nend\n\nperiodic!(fun(setTemperatures), Œît)        # setup the sampling function\nswitch()                                   # start the thermostat\n\n@time run!(ùê∂, 24)                          # run the simulation","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"0.040105 seconds (89.21 k allocations: 3.435 MiB)\n\"run! finished with 0 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating undisturbed\")","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"(Image: svg)","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"Now we have people entering the room or opening windows and thus reducing thermal resistance:","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"function people()\n    delay!(6 + rand(Normal(0, 0.5)))         # sleep until around 6am\n    sleeptime = 22 + rand(Normal(0, 0.5))    # calculate bed time\n    while tau() < sleeptime\n        global Œ∑ = rand()                    # open door or window\n        delay!(0.1 * rand(Normal(1, 0.3)))   # for some time\n        global Œ∑ = 1.0                       # close it again\n        delay!(rand())                       # do something else\n    end\nend\n\nreset!(ùê∂)\nrng = MersenneTwister(122)\nRandom.seed!(1234)\nTe = 11\nTr = 20\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfor i in 1:2                                 # put 2 people in the house\n    process!(Prc(i, people), 1)               # run process only once\nend\nperiodic!(fun(setTemperatures), Œît)    # setup sampling\nswitch()                                     # start the thermostat\n\n@time run!(ùê∂, 24)","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"0.114938 seconds (72.52 k allocations: 2.320 MiB)\n\"run! finished with 116 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating with people\")","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"(Image: svg)","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"We have now all major schemes: events, continuous sampling and processes combined in one example.","category":"page"},{"location":"hybrid/","page":"A hybrid system","title":"A hybrid system","text":"see also: the full house heating example for further explanations.","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Currently you can expect DiscreteEvents to run medium size simulations (with thousands of events) in under 99 ms on a modern computer.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"DiscreteEvents development benchmarks\nM/M/c benchmarks: a story of how to improve a model.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"see also Performance.","category":"page"},{"location":"performance/#Performance","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"For larger models and simulations over longer timeframes performance matters and users can do a lot to get more of it. The generic process of getting more performant simulations is:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Follow the performance tips in the Julia manual,\nfollow the hints in this chapter.","category":"page"},{"location":"performance/#Improving-simulation-performance","page":"Performance","title":"Improving simulation performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"for events use functions or fun instead of quoted expressions.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"If you have tasks in your simulation,","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"generate only the necessary processes/tasks for running the simulation. Avoid long queues of runnable processes or tasks unless absolutely necessary.\nconsider to express parts of your simulation with event-scheduling.\nspeedup your simulation performance by running it on a processor core x1 with onthread(x) do ... end.","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"For one example of how to improve simulation performance please look at the M/M/c queue benchmarks or at M/M/c model way too slow #1.","category":"page"},{"location":"performance/#Run-and-speedup","page":"Performance","title":"Run and speedup","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"If we don't want to compete our processes against other background tasks handled also by the Julia scheduler on thread 1, we can speed up things significantly by executing them on another processor core:","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"onthread(2) do\n    clock = Clock()\n    input = Channel{Int}(Inf)\n    output = Channel{Int}(Inf)\n    for i in 1:num_servers\n        process!(clock, Prc(i, server, i, input, output, service_dist))\n    end\n    process!(clock, Prc(0, arrivals, input, num_customers, arrival_dist), 1)\n    run!(clock, t)\nend","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"note: Note\nFor that to work, JULIA_NUM_TREADS must be set accordingly.","category":"page"},{"location":"models/#Modeling","page":"Models","title":"Modeling","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"beginaligned\nhspace5em  textitAll models are wrong Some are useful (George Box)\nendaligned","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"We have seen different approaches in modeling discrete event systems (DES) for simulation. Most of them are limiting in some way. But DiscreteEvents provides a simple, yet versatile and powerful grammar for combining them.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Sampling: for periodic actions,\nEvent scheduling: for scheduling single events at given times or under given conditions,\nActivities: for expressing an event and the time until another event as an overlapping activities in a system,\nProcesses: for expressing entities with typical sequences of events interacting in a system,\nState Machines: for expressing entities reacting differently to events based on their current state,\nActor systems: for representing systems consisting of multiple nested and parallel interacting components.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"The following examples show how those different approaches to modeling DES can be employed and combined.","category":"page"},{"location":"parallel/#Parallel-simulations","page":"Parallel Simulation","title":"Parallel simulations","text":"","category":"section"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"Currently DiscreteEvents.jl enables two approaches to parallel simulations.","category":"page"},{"location":"parallel/#Simulations-in-parallel","page":"Parallel Simulation","title":"Simulations in parallel","text":"","category":"section"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"Multiple simulations can be executed on parallel to each other using the @threads- macro. They have different clocks with different times. This approach is useful if you do multiple simulations to investigate their response to parameter variation. Basically you write a function, accepting parameters and doing a simulation on them. You then can invoke multiple simulations in a for loop:","category":"page"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"","category":"page"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"See the dice game example.","category":"page"},{"location":"parallel/#distributed_simulations","page":"Parallel Simulation","title":"Distributed simulations","text":"","category":"section"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"An other way is to distribute a simulation over multiple cores of one machine. But this breaks the concept of a universally uniform time in a simulation:","category":"page"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"The concept of a unique global clock is not meaningful in the context of a distributed system of self-contained parallel agents. ...... a unique (linear) global time is not definable. ...This is not to imply that it is impossible to construct a distributed system whose behavior is such that the elements of the system can be abstractly construed as acting synchronously. ... Assume one element, called the global master, controls when each of the elements in the system may continue; ...The important point to be made is that any such global synchronization creates a bottleneck which can be extremely inefficient in the context of a distributed environment. [1]","category":"page"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"In a distributed system we must find a compromise between maintaining a global order of events and being able to do efficient local computations. The key insight is that not all events in a system have causal relations with each other and therefore not all events need to be synchronized.","category":"page"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"DiscreteEvents introduces parallel clocks with thread local time. Thus it maintains partial orderings of events on each thread. By synchronizing the parallel clocks each given time interval œµ it ensures that for all parallel clocks C_i C_j t_i - t_j  œµ.","category":"page"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"It is then up to the user to take care that associated events or entities in a DES get grouped together to run on a thread. Thus causal relations get maintained. In reality subsystems of DES are often decoupled by buffers or queues. Those decouplings are the natural interfaces between subsystems to be used to divide a model over multiple threads.","category":"page"},{"location":"parallel/#Parallel-efficiency","page":"Parallel Simulation","title":"Parallel efficiency","text":"","category":"section"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"number of threads to use,","category":"page"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"see the chapter in performance","category":"page"},{"location":"parallel/#Thread-safety","page":"Parallel Simulation","title":"Thread safety","text":"","category":"section"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"using random numbers on parallel threads,\nsynchronizing write access to shared variables,","category":"page"},{"location":"parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"[1]: Gul Agha: Actors, A Model of Concurrent Computation in Distributed Systems.- 1986, MIT Press, 9ff","category":"page"},{"location":"random/#Randomness","page":"Randomness","title":"Randomness","text":"","category":"section"},{"location":"random/","page":"Randomness","title":"Randomness","text":"The elements introduced so far (clocks, events and processes) let us describe event sequences in discrete event systems (DES). In reality those sequences often show considerable randomness and come out starkly different with varying initial conditions or intervening random events.   ","category":"page"},{"location":"random/","page":"Randomness","title":"Randomness","text":"Random initial states, transition probabilities or stochastic event times can be computed by calling rand(d) on a distribution d from the Distributions package.","category":"page"},{"location":"random/#Two-poisson-processes","page":"Randomness","title":"Two poisson processes","text":"","category":"section"},{"location":"random/","page":"Randomness","title":"Randomness","text":"In the following example we simulate two arrival processes, one homogeneous poisson process (HPP) say for a grocery store and one non-homogeneous poisson process (NHPP) where the number of arrivals diminish over time e.g. for a bakery.","category":"page"},{"location":"random/","page":"Randomness","title":"Randomness","text":"using DiscreteEvents, Random, Distributions, Plots\n\nRandom.seed!(1234)    # set random number seed for reproducibility\nconst Œª = 10          # arrival rate 10 customers per hour\nconst œÅ = log(0.2)/10 # decay constant for customer arrivals\nD = Exponential(1/Œª)  # interarrival time distribution\n\nhpp  = [0]            # counting homogeneous poisson arrivals\nnhpp = [0]            # counting non-homogeneous poisson arrivals\nt = Float64[]         # tracing variables\ny1 = Int[]\ny2 = Int[]\n\nŒ¥(t) = Int(rand() ‚â§ exp(œÅ*t))   # model time dependent decay of arrivals\ntrace(c) = (push!(t, c.time); push!(y1, hpp[1]); push!(y2, nhpp[1]))\n\n# define two arrival functions\n#       |   count             | schedule next arrival\narr1(c) = (hpp[1] += 1;         event!(c, fun(arr1, c), after, rand(D)))\narr2(c) = (nhpp[1]+= Œ¥(c.time); event!(c, fun(arr2, c), after, rand(D)))\n\n# create clock, schedule events and tracing and run\nc = Clock()\nevent!(c, fun(arr1, c), after, rand(D))  # HPP arrivals (grocery store)\nevent!(c, fun(arr2, c), after, rand(D))  # NHPP (bakery)\nperiodic!(c, fun(trace, c))\nrun!(c, 10)\n\nplot(t, y1, label=\"grocery\", xlabel=\"hours\", ylabel=\"customers\", legend=:topleft)\nplot!(t, y2, label=\"bakery\")","category":"page"},{"location":"random/","page":"Randomness","title":"Randomness","text":"(Image: poisson arrivals)","category":"page"},{"location":"random/","page":"Randomness","title":"Randomness","text":"Œ¥(t) defines a time dependent probability of a state transition (customer arrival). The calls to rand(D) create stochastic time sequences (t_1 t_2 t_3 ) of poisson processes.","category":"page"},{"location":"random/","page":"Randomness","title":"Randomness","text":"[","category":"page"},{"location":"examples/postoffice/postoffice/#Post-Office","page":"Post Office","title":"Post Office","text":"","category":"section"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"There is a small post office with one clerk serving the arriving customers. Customers have differing wishes leading to different serving times, from 1 - 5 minutes. We have a little variation in serving times due to variation in customer habits and clerk performance. The arrival rate of customers is about 18 per hour, every 3.33 minutes or 3 minutes, 20 seconds on average. Our post office is small and customer patience is limited, so queue length is limited to 5 customers.","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"We have provided 10% extra capacity, so our expectation is that there should not be too many customers discouraged for long waiting times or for full queues.","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"(Image: post office)","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"Let's do a process-based simulation using DiscreteEvents. We need","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"a source: all the people, providing an unlimited supply for customers,\ncustomers with their demands and their limited patience,\na queue and\nour good old clerk.","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"First we must load the needed modules, describe a customer and define some helper functions:","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"using DiscreteEvents, Random, Distributions, DataFrames\n\nmutable struct Customer\n    id::Int64\n    arrival::Float64\n    request::Int64\n\n    Customer(n::Int64, arrival::Float64) = new(n, arrival, rand(DiscreteUniform(1, 5)))\nend\n\nfull(q::Channel) = length(q.data) >= q.sz_max\nlogevent(nr, queue::Channel, info::AbstractString, wt::Number) =\n    push!(df, (round(œÑ(), digits=2), nr, length(queue.data), info, wt))","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"logevent (generic function with 1 method)","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"Then we define functions for our processes: people and clerk.","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"function people(output::Channel, Œ≤::Float64)\n    i = 1\n    while true\n        Œît = rand(Exponential(Œ≤))\n        delay!(Œît)\n        if !full(output)\n            put!(output, Customer(i, œÑ()))\n            logevent(i, output, \"enqueues\", 0)\n         else\n            logevent(i, output, \"leaves - queue is full!\", -1)\n        end\n        i += 1\n    end\nend\n\nfunction clerk(input::Channel)\n    cust = take!(input)\n    Œît = cust.request + randn()*0.2\n    logevent(cust.id, input, \"now being served\", œÑ() - cust.arrival)\n    delay!(Œît)\n    logevent(cust.id, input, \"leaves\", œÑ() - cust.arrival)\nend","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"clerk (generic function with 1 method)","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"Then we have to create a logging table, register and startup the processes:","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"reset!(ùê∂)  # for repeated runs it is easier if we reset our central clock here\nRandom.seed!(2019)  # seed random number generator for reproducibility\nqueue = Channel(5)  # thus we determine the max size of the queue\n\ndf = DataFrame(time=Float64[], cust=Int[], qlen=Int64[], status=String[], wtime=Float64[])\n\nprocess!(ùê∂, SimProcess(1, people, queue, 3.333)) # register the functions as processes\nprocess!(ùê∂, SimProcess(2, clerk, queue))","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"2","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"Then we can simply run the simulation. We assume our time unit being minutes, so we run for 600 units:","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"println(run!(ùê∂, 600))\nprintln(\"``(length(queue.data)) customers yet in queue\")","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"run! finished with 338 clock events, 0 sample steps, simulation time: 600.0\n0 customers yet in queue","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"Our table has registered it all:","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"df","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"no time cust qlen status wtime\n1 1.2 1 1 enqueues 0.0\n2 1.2 1 0 now being served 0.0\n3 5.46 2 1 enqueues 0.0\n4 5.5 3 2 enqueues 0.0\n5 6.19 1 2 leaves 4.99532\n6 6.19 2 1 now being served 0.737497\n7 7.99 4 2 enqueues 0.0\n8 8.81 2 2 leaves 3.35581\n9 8.81 3 1 now being served 3.30971\n10 12.33 5 2 enqueues 0.0\n11 12.98 3 2 leaves 7.4733\n12 12.98 4 1 now being served 4.98585\n13 13.73 4 1 leaves 5.74268\n14 13.73 5 0 now being served 1.39837\n15 15.72 6 1 enqueues 0.0\n16 17.12 7 2 enqueues 0.0\n17 17.73 5 2 leaves 5.3967\n18 17.73 6 1 now being served 2.00988\n19 20.0 8 2 enqueues 0.0\n20 20.76 9 3 enqueues 0.0\n21 23.26 6 3 leaves 7.53774\n22 23.26 7 2 now being served 6.13554\n23 25.43 10 3 enqueues 0.0\n24 26.0 11 4 enqueues 0.0\n25 26.35 7 4 leaves 9.22525\n26 26.35 8 3 now being served 6.34474\n27 27.49 12 4 enqueues 0.0\n28 27.64 8 4 leaves 7.63665\n29 27.64 9 3 now being served 6.88549\n30 29.06 13 4 enqueues 0.0","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"last(df, 5)","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"no time cust qlen status wtime\n1 589.1 171 1 enqueues 0.0\n2 589.1 171 0 now being served 0.0\n3 593.77 171 0 leaves 4.67801\n4 598.01 172 1 enqueues 0.0\n5 598.01 172 0 now being served 0.0","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"describe(df[df[!, :wtime] .> 0, :wtime])","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"Summary Stats:\nLength:         302\nMissing Count:  0\nMean:           7.486712\nMinimum:        0.009196\n1st Quartile:   3.866847\nMedian:         6.409644\n3rd Quartile:   10.541481\nMaximum:        23.268310\nType:           Float64","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"In 600 minutes simulation time, we registered 172 customers and 505 status changes. The mean and median waiting times were around 7 minutes.","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"by(df, :status, df -> size(df, 1))","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"no status x1\n1 enqueues 167\n2 now being served 167\n3 leaves 166\n4 leaves - queue is full! 5","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"Of the 172 customers, 167 of them participated in the whole process and were served, but 5 left beforehand because the queue was full:","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"df[df.wtime .< 0,:]","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"no time cust qlen status wtime\n1 45.32 19 5 leaves - queue is full! -1.0\n2 249.11 66 5 leaves - queue is full! -1.0\n3 270.04 74 5 leaves - queue is full! -1.0\n4 380.39 106 5 leaves - queue is full! -1.0\n5 382.02 107 5 leaves - queue is full! -1.0","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"using PyPlot\nstep(df.time, df.wtime)\nstep(df.time, df.qlen)\naxhline(y=0, color=\"k\")\ngrid()\nxlabel(\"time [min]\")\nylabel(\"wait time [min], queue length\")\ntitle(\"Waiting Time in the Post Office\")\nlegend([\"wait_time\", \"queue_len\"]);","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"(Image: png)","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"Many customers had waiting times of more than 10, 15 up to even more than 20 minutes. The negative waiting times were the 5 customers, which left because the queue was full.","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"So many customers will remain angry. If this is the situation all days, our post office will have an evil reputation. What should we do?","category":"page"},{"location":"examples/postoffice/postoffice/#Conclusion","page":"Post Office","title":"Conclusion","text":"","category":"section"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"Even if our process runs within predetermined bounds (queue length, customer wishes ‚Ä¶), it seems to fluctuate wildly and to produce unpredicted effects. This is due to variation in arrivals, in demands and in serving time on system performance. In this case 10% extra capacity is not enough to provide enough buffer for variation and for customer service ‚Äì even if our post clerk is the most willing person.","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"Even for such a simple everyday system, we cannot say beforehand ‚Äì without reality check ‚Äì which throughput, waiting times, mean queue length, capacity utilization or customer satisfaction will emerge. Even more so for more complicated systems in production, service, projects and supply chains with multiple dependencies.","category":"page"},{"location":"examples/postoffice/postoffice/","page":"Post Office","title":"Post Office","text":"If we had known the situation beforehand, we could have provided standby for our clerk or install an automatic stamp dispenser for cutting shorter tasks ‚Ä¶ We should have done a simulation before ‚Ä¶","category":"page"},{"location":"par_perf/#Parallel-performance","page":"Parallel performance","title":"Parallel performance","text":"","category":"section"},{"location":"DES/#Discrete-Event-Systems","page":"Overview","title":"Discrete Event Systems","text":"","category":"section"},{"location":"DES/","page":"Overview","title":"Overview","text":"A Discrete Event System (DES) is a discrete-state, event-driven system, that is, its state evolution depends entirely on the occurrence of asynchronous discrete events over time. [1]","category":"page"},{"location":"DES/","page":"Overview","title":"Overview","text":"A DES can be represented as a timed sequence of events","category":"page"},{"location":"DES/","page":"Overview","title":"Overview","text":"(e_1t_1)(e_2t_2)(e_3t_3)hspace1emhspace1em (e_nt_n)","category":"page"},{"location":"DES/","page":"Overview","title":"Overview","text":"Something e_i happens at a time t_i, then another event happens later and so on. From the sequence of events we draw inferences about causality. Sequences and times may change and be associated with probabilities.","category":"page"},{"location":"DES/","page":"Overview","title":"Overview","text":"Following Cassandras [2] we describe DES as stochastic timed automata (mathcalEmathcalXGammapp_0G) where","category":"page"},{"location":"DES/","page":"Overview","title":"Overview","text":"beginarrayrl\n  mathcalE  textrmcountable event set \n  mathcalX  textrmcountable state space \n  Gamma(x)    textrmfeasible event function x in mathcalX Gamma(x) subseteq mathcalE \n  p(xxe)   textrmstate transition probability xx in mathcalX e in mathcalE \n  p_0(x)       textrmpmf PX_0=x x in mathcalX X_o textrminitial state \n  G_i          textrmstochastic clock structure i in mathcalE\nendarray","category":"page"},{"location":"DES/","page":"Overview","title":"Overview","text":"Gamma(x) means that not all events cause a system to change in a given situation or state,\np(xxe) p_0(x) G_i mean that changes, initial states and times or time intervals often are uncertain.","category":"page"},{"location":"DES/","page":"Overview","title":"Overview","text":"To model DES our approach must be able to express computationally all elements in the above definition. DiscreteEvents therefore allows to express 1) events and state transitions, 2) their timing and their 3) stochasticity.","category":"page"},{"location":"DES/","page":"Overview","title":"Overview","text":"In the following pages we introduce how to setup clocks, define actions, ... schedule events, build timed automata and much more.","category":"page"},{"location":"DES/","page":"Overview","title":"Overview","text":"[1]: Cassandras, Lafortune: Introduction to Discrete Event Systems, Springer, 2008, p 30","category":"page"},{"location":"DES/","page":"Overview","title":"Overview","text":"[2]: Ibid. p 334 f.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#Clocks","page":"Internals","title":"Clocks","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"DiscreteEvents.jl contains several clock types: Clock, [ActiveClock]https://pbayer.github.io/DiscreteEvents.jl/dev/usage/#DiscreteEvents.ActiveClock) and RTClock. They are implemented as state machines. Their implementation are internal and not exported.","category":"page"},{"location":"examples/queue_mmc_srv/#M/M/c-Process-based","page":"M/M/c Processes","title":"M/M/c Process based","text":"","category":"section"},{"location":"examples/queue_mmc_srv/","page":"M/M/c Processes","title":"M/M/c Processes","text":"In yet another view we look at entities (e.g. messages, customers, jobs, goods) undergoing a process as they flow through a DES. A process can be viewed as a sequence of events separated by time intervals. Often entities or processes share limited resources. Thus they have to wait for them to become available and then to undergo a transformation (e.g. transport, treatment or service) taking some time.","category":"page"},{"location":"examples/queue_mmc_srv/","page":"M/M/c Processes","title":"M/M/c Processes","text":"This view can be expressed as processes waiting and delaying on a clock or implicitly blocking until they can take! something from a Channel or put! it back. To implement the M/M/c we start right with describing the server and arrivals processes:","category":"page"},{"location":"examples/queue_mmc_srv/","page":"M/M/c Processes","title":"M/M/c Processes","text":"using DiscreteEvents, Printf, Distributions, Random\n\nfunction server(clk::Clock, id::Int, input::Channel, output::Channel, M‚ÇÇ::Distribution)\n    job = take!(input)\n    print(clk, @sprintf(\"%5.3f: server %d serving customer %d\\n\", tau(clk), id, job))\n    delay!(clk, rand(M‚ÇÇ))\n    print(clk, @sprintf(\"%5.3f: server %d finished serving %d\\n\", tau(clk), id, job))\n    put!(output, job)\nend\n\nfunction arrivals(clk::Clock, queue::Channel, N::Int, M‚ÇÅ::Distribution)\n    for i = 1:N # initialize customers\n        delay!(clk, rand(M‚ÇÅ))\n        put!(queue, i)\n        print(clk, @sprintf(\"%5.3f: customer %d arrived\\n\", tau(clk), i))\n    end\nend","category":"page"},{"location":"examples/queue_mmc_srv/","page":"M/M/c Processes","title":"M/M/c Processes","text":"Then we setup our constants, the simulation environment with clock, channels and processes and run:","category":"page"},{"location":"examples/queue_mmc_srv/","page":"M/M/c Processes","title":"M/M/c Processes","text":"Random.seed!(8710)          # set random number seed for reproducibility\nconst N = 10                # total number of customers\nconst c = 2                 # number of servers\nconst Œº = 1.0 / c           # service rate\nconst Œª = 0.9               # arrival rate\nconst M‚ÇÅ = Exponential(1/Œª) # interarrival time distribution\nconst M‚ÇÇ = Exponential(1/Œº) # service time distribution\n\n# initialize the simulation environment and run\nclock = Clock()\ninput = Channel{Int}(Inf)\noutput = Channel{Int}(Inf)\nfor i in 1:c\n    process!(clock, Prc(i, server, i, input, output, M‚ÇÇ))\nend\nprocess!(clock, Prc(0, arrivals, input, N, M‚ÇÅ), 1)\nrun!(clock, 20)","category":"page"},{"location":"examples/queue_mmc_srv/","page":"M/M/c Processes","title":"M/M/c Processes","text":"We get the following output:","category":"page"},{"location":"examples/queue_mmc_srv/","page":"M/M/c Processes","title":"M/M/c Processes","text":"0.123: customer 1 arrived\n0.123: server 1 serving customer 1\n0.226: customer 2 arrived\n0.226: server 2 serving customer 2\n....\n9.475: customer 9 arrived\n9.475: server 2 serving customer 9\n10.027: server 1 finished serving 8\n10.257: customer 10 arrived\n10.257: server 1 serving customer 10\n10.624: server 1 finished serving 10\n10.734: server 2 finished serving 9\n\"run! finished with 50 clock events, 0 sample steps, simulation time: 20.0\"","category":"page"},{"location":"examples/queue_mmc_srv/","page":"M/M/c Processes","title":"M/M/c Processes","text":"Note that","category":"page"},{"location":"examples/queue_mmc_srv/","page":"M/M/c Processes","title":"M/M/c Processes","text":"the times deviate from the activity based implementation because here we do not use conditional events and therefore have no time divergence due to sampling [1].\nProcesses must transfer IO-operations with a now! call to the clock.","category":"page"},{"location":"examples/queue_mmc_srv/","page":"M/M/c Processes","title":"M/M/c Processes","text":"[1]: the load activity in the activity-based example uses a conditional event. The condition is then checked periodically with sampling. That introduces a time divergence into the simulation. Instead in the process-based example the blocking on channels is handled by Julia internally and we need not to wait conditionally on the clock.","category":"page"},{"location":"examples/dicegame/dicegame/#Goldratt's-Dice-Game","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"","category":"section"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Goldratt's Dice Game from his business novel \"The Goal\" is a classical illustration that dependencies and statistical fluctuations diminish the throughput through a system.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Alex Rogo, the hero of the novel plays a game with five boys:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"While they go get the others, I figure out the details. The system I've set up is intended to \"process\" matches. It does this by moving a quantity of match sticks out of their box, and through each of the bowls in succession. The dice determine how many matches can be moved from one bowl to the next. The dice represent the capacity of each resource, each bowl; the set of bowls are my dependent events, my stages of production. Each has exactly the same capacity as the others, but its actual yield will fluctuate somewhat.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"In order to keep those fluctuations minimal, however, I decide to use only one of the dice. This allows the fluctuations to range from one to six. So from the first bowl, I can move to the next bowls in line any quantity of matches ranging from a minimum of one to a maximum of six.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Throughput in this system is the speed at which matches come out of the last bowl, Inventory consists of the total number of matches in all of the bowls at any time. And I'm going to assume that market demand is exactly equal to the average number of matches that the system can process. Production capacity of each resource and market demand are perfectly in balance. So that means I now have a model of a perfectly balanced manufacturing plant.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Five of the boys decide to play. Besides Dave, there are Andy, Ben, Chuck, and Evan. Each of them sits behind one of the bowls. I find some paper and a pencil to record what happens. Then I explain what they're supposed to do.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"\"The idea is to move as many matches as you can from your bowl to the bowl on your right. When it's your turn, you roll the die, and the number that comes up is the number of matches you can move. Got it?\"","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"They all nod. \"But you can only move as many matches as you've got in your bowl. So if you roll a five and you only have two matches in your bowl, then you can only move two matches. And if it comes to your turn and you don't have any matches, then naturally you can't move any.\"","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Eliyahu M Goldratt: The Goal.‚Äì 3rd ed, p. 105","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Then Rogo explains to the boys that with the die on average they should pass 3.5 matches through the system, so after twenty cycles they should have got an output of seventy.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: The Dice Game)","category":"page"},{"location":"examples/dicegame/dicegame/#An-assembly-line","page":"Goldratt's Dice Game","title":"An assembly line","text":"","category":"section"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"As Goldratt described it, the game is done in a fixed cycle ‚Äì no asynchronism here and no need for a discrete-event-simulation. But more realistically it could be seen as an assembly line with buffers between the five workers:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: assembly line)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The workers take on average 3.5 time units for processing an item and they are admonished to work as fast as possible. To implement it, we need some data structure for workers ‚Ä¶","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using DiscreteEvents, Distributions, DataFrames, Random\n\nmutable struct Worker\n    nr::Int64              # worker number\n    clk::Clock\n    input::Channel  \n    output::Channel\n    dist::Distribution     # distribution of processing time\n    retard::Float64        # worker retard factor, 1: no retardation, >1: retardation\n    done::Int64            # number of finished items\n\n    Worker(nr, clk, input, output, dist, perform) = new(nr, clk, input, output, dist, 1/perform, 0)\nend","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"‚Ä¶ and a function representing their operation. The buffers are represented by channels. Then we build the system by creating workers and connecting them by channels. We start the work processes with their respective data and run the simulation.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"stats(t::Float64, nr::Int64, len::Int64) = push!(df, (t, nr, len))  ## write buffersize to dataframe\n\nfunction work(w::Worker, stat::Bool)\n    job = take!(w.input)\n    stat ? stats(tau(w.clk), w.nr, length(w.input.data)) : nothing\n    delay!(w.clk, rand(w.dist) * w.retard)\n    put!(w.output, job)\n    stat ? stats(tau(w.clk), w.nr+1, length(w.output.data)) : nothing\n    w.done += 1\nend\n\nreset!(ùê∂)\nRandom.seed!(1234)                 # seed random number generator\ndf = DataFrame(time=Float64[], channel=Int[], length=Int[])\n\nC = [Channel{Int64}(Inf) for i in 1:6]    # create 6 channels\nj = reverse(Array(1:8))\nfor i in 5:-1:2                    # seed channels 2:5 each with 2 inventory items\n    put!(C[i], j[(i-1)*2])\n    put!(C[i], j[(i-1)*2-1])\nend\nfor i in 9:1000                    # put other 992 jobs into channel 1\n    put!(C[1], i)\nend\n\nW = [Worker(i, ùê∂, C[i], C[i+1], Uniform(0.5, 6.5), 1.0) for i in 1:5]\nfor i in 1:5\n    process!(SP(i, work, W[i], true))\nend\n@time run!(ùê∂, 1000)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"0.261483 seconds (115.06 k allocations: 4.404 MiB)\n\"run! finished with 1390 clock events, 0 sample steps, simulation time: 1000.0\"","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"length(C[6].data)                    # how much got produced?","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"272","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"1000/272","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"3.676470588235294","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"After running for 1000 time units, we got 272 finished items in channel 6, meaning an average cycle time of 3.68, not 3.5 as expected. The expected throughput would have been 286 units, so the line produced only 95% of that, even under \"perfect\" conditions like unlimited supply, an in-process inventory to start with, infinite buffer sizes, a perfectly balanced line and equally performing workers without breaks ‚Ä¶ What happened?","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using Plots\n\nfunction inventory_plot(n::Int64, title)\n    for i ‚àà 2:n\n        d = df[df.channel .== i, :]\n        doplot = i == 2 ? plot : plot!\n        doplot(d.time, d.length, label=\"channel$i\")\n    end\n    title!(title)\n    xlabel!(\"time\")\n    ylabel!(\"Inventory\")\nend\ninventory_plot(5, \"In-Process-Inventory of Dice-Line\")","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We see that statistical fluctuations in processing times (the dice!) lead to wildly fluctuating buffers, overproduction of worker 1 (look at channel 2) and also to starvation of other workers down the line when their input buffers are empty. Let's calculate the inventory of unfinished goods in the line at the end of the simulation run:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"1000-length(C[1].data)-length(C[6].data)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"26","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"This gives an average of 6.5 inventory items in channels 2-5. But as we see in the plot, some channels are often empty, leading to some starvation.","category":"page"},{"location":"examples/dicegame/dicegame/#Parametrizing-the-model","page":"Goldratt's Dice Game","title":"Parametrizing the model","text":"","category":"section"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"For further investigations we parametrize our model. This is not easily done in graphically oriented simulators, but we can do it with DiscreteEvents.jl.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"As parameters we take:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"n: the length of the line (number of workers)\nmw: max WIP-buffer sizes (WIP is work in progress),\nvp: variation in processing times from item to item and,\nvw: variation between worker performance,\nd: the duration of the simulation run","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We give each simulation its own clock and channels variables so that it can be run in parallel on different threads.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"function dice_line( n::Int64, mw::Int64,\n                    vp::Distribution, vw::Distribution;\n                    d=1000, seed=1234, jobs=1000, stat::Bool=true )\n    clk = Clock()\n    Random.seed!(seed)                  # seed random number generator\n    stat ? ( global df = DataFrame(time=Float64[], channel=Int[], length=Int[]) ) : nothing\n    C = [Channel{Int64}(mw) for i in 1:n+1] # create n+1 channels with given buffer sizes\n    C[1] = Channel{Int64}(Inf)                 # unlimited sizes for channels 1 and n+1\n    C[n+1] = Channel{Int64}(Inf)\n    j = reverse(Array(1:(n-1)*2))\n    for i in n:-1:2                     # seed channels 2:(n-1) each with 2 inventory items\n        C[i].sz_max > 0 ? put!(C[i], j[(i-1)*2]) : nothing\n        C[i].sz_max > 1 ? put!(C[i], j[(i-1)*2-1]) : nothing\n    end\n    for i in ((n-1)*2+1):jobs           # put other jobs into channel 1\n        put!(C[1], i)\n    end\n\n    wp = rand(vw, n)                    # calculate worker performance\n    W = [Worker(i, clk, C[i], C[i+1], vp, wp[i]) for i in 1:n]\n    for i in 1:n\n        process!(clk, SP(i, work, W[i], stat))\n    end\n    info = run!(clk, d)\n    return (info, clk.evcount, length(C[end].data))\nend","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"dice_line (generic function with 1 method)","category":"page"},{"location":"examples/dicegame/dicegame/#Kanban-‚Ä¶","page":"Goldratt's Dice Game","title":"Kanban ‚Ä¶","text":"","category":"section"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Against too much inventory we have Kanban. So let's introduce maximum buffer sizes of 5 items. We have yet our five perfect workers without varying performance.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using Printf\ninfo, ev, res = dice_line(5, 5, Uniform(0.5, 6.5), Normal(1,0))\nprintln(info)\nprintln(res, \" items produced!\")\n@printf(\"%5.2f%s capacity utilization\", 3.5*res/10, \"%\")","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"run! finished with 1341 clock events, 0 sample steps, simulation time: 1000.0\n266 items produced!\n93.10% capacity utilization","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Uups! We throttled our system further, to an output of 266.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"inventory_plot(5, \"In-Process-Inventory of kanbanized Dice-Line\")","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"But we got much less inventory in the system. The throttling occurs because with Kanban in-process-inventories get more often to zero. Seemingly Kanban is no solution for our throughput problem but constrains the system further. With Kanban we have reduced unpredictability and instability in inventory.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Let's pause a moment to look at what we have here: we got a small model with which we can simulate and analyze the impact of dependencies (line length and buffer sizes) and statistical fluctuations (in processing time and worker performance) on simple assembly lines like there are thousands in industry. This is no minor achievement.","category":"page"},{"location":"examples/dicegame/dicegame/#Investigating-assembly-lines","page":"Goldratt's Dice Game","title":"Investigating assembly lines","text":"","category":"section"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"With the parametrized model we can do some investigations into the behaviour of assembly lines.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"For that we take first some further simplification steps:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We normalize the model by assuming a mean processing time of 1.\nWe choose a gamma distribution as more realistic for processing times than the uniform distribution, we used until now following Goldratt's example:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using StatsPlots, LaTeXStrings\n\nfor i in [2,3,5,10,15,20]\n    doplot = i == 2 ? plot : plot!\n    doplot(Gamma(i, 1/i), label=latexstring(\"a=$i, \\\\theta=$(round(1/i, digits=2))\"))\nend\nxlabel!(L\"\\mathsf{processing\\, time}\")\nylabel!(L\"\\mathsf{probability\\, density}\")\ntitle!(latexstring(\"\\\\mathsf{Gamma\\\\, distribution,\\\\,} \\\\mu=1\"))","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@time info, ev, res = dice_line(5, 5, Gamma(10,1/10), Normal(1,0))\nprintln(info)\nprintln(res, \" items produced!\")\n@printf(\"y = %5.3f [1/t]\", res/1000)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"1.060803 seconds (1.03 M allocations: 46.115 MiB, 1.03% gc time)\nrun! finished with 4847 clock events, 0 sample steps, simulation time: 1000.0\n966 items produced!\ny = 0.966 [1/t]","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"inventory_plot(5, \"In-Process-Inventory of kanbanized Dice-Line\")","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Before we go deeper into parameters, we have to check how much path dependence and statistical fluctuations vary the outcome. Therefore we repeat the simulation 30 times with different random number seeds and analyze the distribution of the outcome. As outcome we choose the throughput rate y [1/t] which is also an indicator for line performance.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Random.seed!(1234)\ns = abs.(rand(Int, 30))\ntc = ones(30)\nThreads.@threads for i = 1:30\n    info, ev, res = dice_line(5, 5, Gamma(10,1/10), Normal(1,0), seed=s[i], jobs=1200, stat=false)\n    tc[i] = res*0.001\nend\nys = (Œº=mean(tc), œÉ=std(tc))\n@printf(\"Œº: %5.3f, œÉ: %5.3f, LCL: %5.3f, UCL: %5.3f\\n\", ys.Œº, ys.œÉ, ys.Œº-3ys.œÉ, ys.Œº+3ys.œÉ)\nplot(1:30, tc, title=\"throughput rate of various runs of dice line\", xlabel=\"runs\",\n    ylabel=\"y [1/t]\", legend=:none, lw=2)\nhline!([ys.Œº, ys.Œº-3ys.œÉ, ys.Œº+3ys.œÉ], lc=:red)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Œº: 0.967, œÉ: 0.006, LCL: 0.950, UCL: 0.984","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#Experimental-design","page":"Goldratt's Dice Game","title":"Experimental design","text":"","category":"section"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Our response variable y seems to be under statistical control and its fluctuation is of the same order as the effects we are after. But with an experimental design those fluctuations should cancel out. We setup it up with:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"n: number of workers, line length,\nb: buffersize between workers,\na: shape parameter of gamma distribution of processing times (bigger a means less variation),\nœÉ: standard deviation of performance variation between workers.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using StatsModels, ExperimentalDesign\n\nn = vcat(5:10,12:2:20)\nb = 1:10\na = vcat(2,3,5:5:20)\nœÉ = LinRange(0,0.1,5)\n\nD = FullFactorial((n=n, b=b, a=a, œÉ=œÉ), @formula(y ~ n + b + a + œÉ), explicit = true)\nsize(D.matrix)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(3300, 4)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We got a design matrix with 3300 rows for 3300 simulations! Let's do something else while the computer works:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"y = zeros(3300)\nevents = 0\nt = @elapsed begin\n    Threads.@threads for i = 1:3300\n        p = Tuple(D.matrix[i, :])\n        info, ev, res = dice_line(p[1], p[2], Gamma(p[3], 1/p[3]), Normal(1, p[4]), jobs=1200, stat=false )\n        y[i] = res*0.001\n        global events += ev\n    end\nend\n@printf(\"Time elapsed: %5.2f minutes, %d events on %d threads\", t/60, events, Threads.nthreads())","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Time elapsed:  4.02 minutes, 33513556 events on 4 threads","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"It takes 4 minutes on 4 threads of a 2013 MacBook Pro and over 33times 10^6 events.","category":"page"},{"location":"examples/dicegame/dicegame/#Data-analysis","page":"Goldratt's Dice Game","title":"Data analysis","text":"","category":"section"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We put together a results table and do some exploratory data analysis:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"res = D.matrix\nres.y = y\ndescribe(y)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Summary Stats:\nLength:         3300\nMissing Count:  0\nMean:           0.892569\nMinimum:        0.633000\n1st Quartile:   0.863750\nMedian:         0.904000\n3rd Quartile:   0.937000\nMaximum:        0.986000\nType:           Float64","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The performance of our simulated assembly lines varies between 0.637 and 0.986, which is a huge difference: The worst result is 35.8% below the best one!","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"vcat(res[y .== maximum(y), :], res[y .== minimum(y), :])","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"no n b a œÉ y\n1 6 7 20 0.0 0.986\n2 5 10 20 0.0 0.986\n3 18 1 2 0.05 0.633","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The best performance is with the shortest lines, big buffer sizes, small variation in processing times and no variation in performance between workers. But this is just common sense. The worst performance is with a long line, minimum buffers and maximum variation in processing times and in performance between workers. But how big are the effects?","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@df res dotplot(:n, :y, title=\"line performance vs line length\", xlabel=\"n\", ylabel=\"y [1/t]\",\n    marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(:n, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@df res dotplot(:b, :y, title=\"line performance vs buffer size\", xlabel=\"b\", ylabel=\"y [1/t]\",\n    marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(:b, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@df res dotplot(:a, :y, title=\"line performance vs processing time variation\", xlabel=\"a (bigger a: less variation)\",\n    ylabel=\"y [1/t]\", marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(:a, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = Int.(round.(res.œÉ*40))\n@df res dotplot(x, :y, title=\"line performance vs worker performance variation\", xlabel=L\"\\sigma\", ylabel=\"y [1/t]\",\n    marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(x, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))\nxticks!(collect(0:4), string.(round.(œÉ, digits=3)))","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Buffer sizes and variation in processing time clearly have nonlinear effects while line length and performance variation between workers seem to have more linear ones. Small buffers and variation in processing time constrain the line the most and also are responsible for the worst performances. There seems to be also an interaction between those major two factors.","category":"page"},{"location":"examples/dicegame/dicegame/#Statistical-model","page":"Goldratt's Dice Game","title":"Statistical model","text":"","category":"section"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We fit a linear model to the results and account for the nonlinearities with logarithmic terms:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using GLM\n\nols = lm(@formula(y ~ 1 + n + log(1+b) + log(a) + œÉ), res)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\ny ~ 1 + n + :(log(1 + b)) + :(log(a)) + œÉ\n\nCoefficients:\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                Estimate   Std. Error   t value  Pr(>|t|)    Lower 95%    Upper 95%\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n(Intercept)   0.738014    0.00235126   313.881     <1e-99   0.733404     0.742624  \nn            -0.00154928  9.81169e-5   -15.7902    <1e-53  -0.00174166  -0.00135691\nlog(1 + b)    0.0576481   0.000897264   64.2488    <1e-99   0.0558889    0.0594074\nlog(a)        0.050857    0.000564214   90.1378    <1e-99   0.0497508    0.0519633\nœÉ            -0.508588    0.0133498    -38.097     <1e-99  -0.534763    -0.482413  \n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"All parameters are highly significant. We find then - as expected - that the b&a-interaction between buffer size and variation in processing times is highly significant too:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"ols2 = lm(@formula(y ~ 1 + n + log(1+b)*log(a) + œÉ), res)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\ny ~ 1 + n + :(log(1 + b)) + :(log(a)) + œÉ + :(log(1 + b)) & :(log(a))\n\nCoefficients:\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                        Estimate   Std. Error   t value  Pr(>|t|)    Lower 95%    Upper 95%\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n(Intercept)           0.5992      0.00314399   190.586     <1e-99   0.593035     0.605364  \nn                    -0.00154928  7.21745e-5   -21.4658    <1e-95  -0.00169079  -0.00140777\nlog(1 + b)            0.13696     0.00163887    83.5699    <1e-99   0.133747     0.140173  \nlog(a)                0.123869    0.00144194    85.9039    <1e-99   0.121041     0.126696  \nœÉ                    -0.508588    0.00982009   -51.7906    <1e-99  -0.527842    -0.489334  \nlog(1 + b) & log(a)  -0.0417155   0.000788995  -52.8716    <1e-99  -0.0432624   -0.0401685\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Then we can analyze the effects of the four parameters on line performance:","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = LinRange(1,10,50)\nfor i in reverse(a)\n    _n = fill(mean(n), length(x))\n    _a = fill(i, length(x))\n    _œÉ = fill(mean(œÉ), length(x))\n    tmp = DataFrame(n=_n, b=x, a=_a, œÉ=_œÉ)\n    _y = predict(ols2, tmp)\n    doplot = i == 20 ? plot : plot!\n    doplot(x, _y, label=\"a=$i\")\nend\ntitle!(\"Effects of buffer size and processing time variation\", legend=:bottomright)\nxlabel!(\"b (buffer size)\")\nylabel!(\"y [1/t]\")","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Buffer size and processing time variation have nonlinear effects and may account together for 26% line performance losses. This shows how important it is to increase buffer sizes with larger variation in processing times (smaller a). Only with small variation one can reduce buffers without loosing much performance.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = LinRange(5, 20, 50)\ntmp = DataFrame(n=x, b=fill(mean(b), length(x)), a=fill(mean(a), length(x)),\n    œÉ=fill(mean(œÉ), length(x)))\nplot(x, predict(ols2, tmp), title=\"Effect of line length\", xlabel=\"n (line length)\",\n    ylabel=\"y [1/t]\", legend=:none)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"This may account for 3% performance losses.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = LinRange(0,0.1,50)\ntmp = DataFrame(n=fill(mean(n), length(x)), b=fill(mean(b), length(x)),\n    a=fill(mean(a), length(x)), œÉ=x)\nplot(x, predict(ols2, tmp), title=\"Effect of performance variation between workers\",\n    xlabel=L\"\\sigma\", ylabel=\"y [1/t]\", legend=:none)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Variation in performance between workers may diminish line throughput by other 5%.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The four effects combined can account for 34% performance losses from best to worst. This is most of the 35.8% we found above. The rest is mostly statistical fluctuations.","category":"page"},{"location":"examples/dicegame/dicegame/#Final-remark","page":"Goldratt's Dice Game","title":"Final remark","text":"","category":"section"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Starting from a simple game and with only a quite small simulation model we could come to conclusions with a wide applicability for assembly lines. The performance differences in assembly lines are realistic ‚Äì I have seen them over and over in industry. And we didn't yet account for failures or supply shortfalls. The unawareness of those simple factors costs manufacturing industry billions.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The most interesting thing to note here is, that from seemingly quite unpredictable behaviour ‚Äì look at the inventory chart of the beginning ‚Äì emerge some quite predictable characteristics out of multiple discrete event simulations with parameter variation combined with some not too sophisticated statistics.","category":"page"},{"location":"examples/dicegame/dicegame/","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We could not have done those experiments and analyses with real lines as it is possible with simulations on a modern computer with Julia and DiscreteEvents.jl.","category":"page"},{"location":"examples/house_heating/house_heating/#House-heating","page":"House Heating","title":"House heating","text":"","category":"section"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"In a hybrid system we have continuous processes and discrete events interacting in one system. A thermostat is a basic example of this:","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"Heating changes between two states: On and Off,\na room cools  at a certain rate dotQ_c Jh proportional to the difference between room temperature T_r and environment temperature T_e K,\nit heats at a rate dotQ_h Jh proportional to the temperature difference between temperature of the heating fluid T_h K and room temperature T_r K,\nthe room temperature T_r changes proportionally to the difference between heating dotQ_h and cooling dotQ_c.","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"beginarrayrl\ndotQ_c = fracleft(T_r - T_eright)eta R  lefttfracJhright  mathrmwhere R = thermal resistance lefttfracK hJright eta = efficiency  factor le 10\ndotQ_h = alpha left(T_h - T_rright)  lefttfracJhright  mathrmwhere alpha = proportionality factor lefttfracJK hright \ndotT_h = beta left(dotQ_h - dotQ_cright) lefttfracKhright  mathrmwhere beta = proportionality factor lefttfracKJright\ndotT_c = - beta dotQ_c lefttfracKhright  mathrmwhen heating is switched off\nendarray","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"We assume that","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"the thermostat is set to switch heating on if T_r falls under 20¬∞C and to switch heating off if T_r rises above 23¬∞C,\ntime units are hours,\nthe temperature T_h of the heating fluid is 40¬∞C,\nthe temperature T_e of the environment follows a stochastic process based on a sine function between 8 and 20¬∞C with T_emin at 4am and T_emax at 4pm,\nthe constants have values R = 1times10^-6 leftfracK hJright alpha = 2times 10^6 leftfracJK hright beta = 3times 10^-7 leftfracKJright,\npeople entering the room may reduce insulation efficiency by a factor etale10 to R,\nthe room temperature is initially T_r0 = 20 C and\nthe heater is off.","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"First we setup the physical model:","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"using DiscreteEvents, Plots, DataFrames, Random, Distributions, LaTeXStrings\n\nconst Th = 40     # temperature of heating fluid\nconst R = 1e-6    # thermal resistance of room insulation\nconst Œ± = 2e6     # represents thermal conductivity and capacity of the air\nconst Œ≤ = 3e-7    # represents mass of the air and heat capacity\nŒ∑ = 1.0           # efficiency factor reducing R if doors or windows are open\nheating = false\n\nŒîte(t, t1, t2) = cos((t-10)*œÄ/12) * (t2-t1)/2  # change of a sinusoidal Te\n\nfunction Œîtr(Tr, Te, heating)\n    Œîqc = (Tr - Te)/(R * Œ∑)                    # cooling rate\n    Œîqh = heating ? Œ± * (Th - Tr) : 0          # heating rate\n    return Œ≤ * (Œîqh - Œîqc)                     # change in room temperature\nend","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"We now setup a simulation for 24 hours. We update the simulation every virtual minute.","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"reset!(ùê∂)                     # reset the clock\nrng = MersenneTwister(122)    # seed the random number generator\nŒît = 1//60                    # update every minute\nTe = 11                       # start value for environment temperature\nTr = 20                       # start value for room temperature\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfunction setTemperatures(t1=8, t2=20)  # change the temperatures\n    global Te += Œîte(tau(), t1, t2) * 2œÄ/1440 + rand(rng, Normal(0, 0.1))\n    global Tr += Œîtr(Tr, Te, heating) * Œît\n    push!(df, (tau(), Tr, Te, Int(heating)) ) # append stats to the table\nend\n\nfunction switch(t1=20, t2=23)                 # simulate the thermostat\n    if Tr ‚â• t2\n        global heating = false\n        event!(SF(switch, t1, t2), @val :Tr :‚â§ t1)  # setup a conditional event\n    elseif Tr ‚â§ t1\n        global heating = true\n        event!(SF(switch, t1, t2), @val :Tr :‚â• t2)  # setup a conditional event\n    end\nend\n\nDiscreteEvents.sample!(SF(setTemperatures), Œît) # setup sampling\nswitch()                                       # start the thermostat\n\n@time run!(ùê∂, 24)","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"0.040105 seconds (89.21 k allocations: 3.435 MiB)\n\"run! finished with 0 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating undisturbed\")","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"(Image: svg)","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"In a living room the thermal resistance is repeatedly diminished if people enter the room or open windows.","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"function people()\n    delay!(6 + rand(Normal(0, 0.5)))         # sleep until around 6am\n    sleeptime = 22 + rand(Normal(0, 0.5))    # calculate bed time\n    while tau() < sleeptime\n        global Œ∑ = rand()                    # open door or window\n        delay!(0.1 * rand(Normal(1, 0.3)))   # for some time\n        global Œ∑ = 1.0                       # close it again\n        delay!(rand())\n    end\nend\n\nreset!(ùê∂)                                    # reset the clock\nrng = MersenneTwister(122)\nRandom.seed!(1234)\nTe = 11\nTr = 20\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfor i in 1:2                                 # put 2 people in the house\n    process!(SP(i, people), 1)               # run process only once\nend\nDiscreteEvents.sample!(SF(setTemperatures), Œît)    # set sampling function\nswitch()                                     # start the thermostat\n\n@time run!(ùê∂, 24)","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"0.114938 seconds (72.52 k allocations: 2.320 MiB)\n\"run! finished with 116 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating with people\")","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"(Image: svg)","category":"page"},{"location":"examples/house_heating/house_heating/","page":"House Heating","title":"House Heating","text":"We have now all major schemes: events, continuous sampling and processes combined in one example.","category":"page"},{"location":"events/#Event-Scheduling","page":"Events","title":"Event Scheduling","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"In order to represent an event (e_it_i) e_i in mathcalE we schedule an appropriate action Œ≥ to clock at a given time or under a condition. Thereby we introduce a time delay between the creation of an event and its execution.","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"Timed events are actions scheduled to execute at a given time,\nConditional events are actions scheduled to execute when a given condition becomes true.","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"Events can be scheduled to a clock before or during it is running. But they are executed at their due time only by a running clock.","category":"page"},{"location":"events/#Timed-events","page":"Events","title":"Timed events","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"With a clock C, an action gamma and a known event time t we can schedule timed events:","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"event!(C, ùú∏, t) or event!(C, ùú∏, at, t): hspace3ptC executes Œ≥ at time t,\nevent!(C, ùú∏, after, Œît): hspace3ptC executes Œ≥ after a time interval Œît,\nevent!(C, ùú∏, every, Œît): hspace3ptC executes Œ≥ every time interval Œît.","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"There t or Œît can be numbers or Distributions.","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"using DiscreteEvents, Plots\n\nc = Clock()\na = [0]                                                       # a counting variable\nx = Float64[]; ya = Float64[]                                 # tracing variables\n\nevent!(c, ()->a[1]+=1, 1)                                     # increment a[1] at t=1\nevent!(c, ()->a[1]=4, after, 5)                               # set a[1]=4 after Œît=5\nevent!(c, fun(event!, c, ()->a[1]+=1, every, 1), at, 5)       # starting at t=5 trigger a repeating event\nevent!(c, ()->(push!(x,tau(c)); push!(y, a[1])), every, 0.01) # trace t and a[1] every Œît=0.01\n\nrun!(c, 10.1)\nplot(x, y, linetype=:steppost, xlabel=\"t\", ylabel=\"a\", legend=false)","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"(Image: timed events)","category":"page"},{"location":"events/#Conditional-events","page":"Events","title":"Conditional events","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"With a conditional event: event!(C, Œ≥, Œæ) the clock C executes the pseudo action Œæ at its sample rate Œît. Œæ must check for event conditions. As soon as it returns true, the clock executes Œ≥. If Œæ is a tuple of actions, all of them must return true to trigger the execution of Œ≥.","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"c = Clock()\na = [0.0]; b = [0]\nx = Float64[]; ya = Float64[]; yb = Float64[]\n\nevent!(c, ()->a[1]=tau(c)^2, every, 0.1)            # calculate a[1]=t^2 every Œît=0.1\nevent!(c, ()->b[1]=25, ()->a[1]‚âà25)                 # set b[1]=25 if a[1]‚âà25\nevent!(c, ()->(push!(x,tau(c)); push!(ya,a[1]); push!(yb,b[1])), every, 0.01) # trace t, a[1], b[1],\n\nrun!(c, 10)\nplot(x, ya, xlabel=\"t\", ylabel=\"y\", label=\"a\", legend=:topleft)\nplot!(x, yb, label=\"b\")","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"(Image: conditional event)","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"A conditional event introduces a time uncertainty Œ∑  Œît into simulations caused by the clock sample rate Œît.","category":"page"},{"location":"events/#Stochastic-time-variables","page":"Events","title":"Stochastic time variables","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"By using a Distribution as time variable for a timed event!, you can create stochastic processes easily:","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"using Distributions\nc = Clock()\nŒª = 0.5\na = [0]\nt = Float64[0.0]; y = Float64[0.0]\nincra(c) = (a[1]+=1; push!(t, tau(c)); push!(y, a[1]))\nevent!(c, fun(incra, c), every, Exponential(1/Œª))\nrun!(c, 100)\nplot(t, y, linetype=:steppost, xlabel=\"t\", ylabel=\"y\", title=\"Poisson Process\", legend=false)","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"(Image: poisson process)","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"see also: event!","category":"page"},{"location":"automata/#State-Machines","page":"State Machines","title":"State Machines","text":"","category":"section"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"In DES usually a lot of events happen, but not all of them cause state transitions. On the other hand some events cause a system to change its path. If event sequences ...","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"(e_1t_1)(e_2t_2)(e_3t_3)hspace1emhspace1em (e_nt_n)","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"are not predictable and can change stochastically, the system behavior can be expressed as a finite state machine. In our stochastic timed automaton (mathcalEmathcalXGammapp_0G) the feasible event function Gamma(x)  x in mathcalXGamma(x) subseteq mathcalE is the set of all events e for which a transition function mathcalf(xe) is defined. Given the current state of the system other events can happen, but are unfeasible and are ignored.","category":"page"},{"location":"automata/#The-transition-function","page":"State Machines","title":"The transition function","text":"","category":"section"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"mathcalfmathcalXtimesmathcalE rightarrow mathcalX describes the transitions in the system and is only partially defined on its domain. Julia's multiple dispatch allows to implement it as different methods of one function:","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"define the event set mathcalE = alpha beta gamma ,\ndefine the state space mathcalX=x_1 x_2  x_n,\nimplement methods for the defined transitions mathcalf(x_1 alphabeta) mathcalf(x_2 gamma)  mathcalf(x_n omega),\ndefine a default transition mathcalf(xmathcalE)=x.","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"Defined transitions call one of the defined methods and undefined transitions fall back to the default transition.","category":"page"},{"location":"automata/#An-example","page":"State Machines","title":"An example","text":"","category":"section"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"We have to model a system where servers break down from time to time. First we implement the states and the events occurring in the system and a server type:","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"abstract type ùëã end    # define states\nstruct Idle <: ùëã end\nstruct Busy <: ùëã end\nstruct Failed <: ùëã end\n\nabstract type ùê∏ end    # describe events\nstruct Setup <: ùê∏ end\nstruct Load <: ùê∏ end\nstruct Finish <: ùê∏ end\nstruct Fail <: ùê∏ end\nstruct Repair <: ùê∏ end\n\nmutable struct Server  # state machine body\n    id::Int\n    c::Clock\n    state::ùëã\n    job::Int\nend","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"Then we implement the transition function as f!(s,x,e) [1] with s for the server instance and different methods for all defined (xe)rightarrow x transitions and a default transition. This enables us to dispatch on them:","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"ùíá!(::Server, ::ùëã, ::ùê∏) = nothing   # default transition\nùíá!(s::Server, ::Idle, ::Setup) =   # a setup event for an idle machine\n    event!(s.c, fun(ùíá!, s, s.state, Load()), fun(isready, queue))\nfunction ùíá!(s::Server, ::Idle, ::Load) # a load event for an idle machine\n    s.job = pop!(queue)\n    s.state = Busy()\n    event!(s.c, fun(ùíá!, s, s.state, Finish()), after, rand(EX))\nend\nfunction ùíá!(s::Server, ::Union{Idle,Busy}, ::Fail) # a fail event for idle and busy machines\n    s.state = Failed()\n    event!(s.c, fun(ùíá!, s, s.state, Repair(), after, rand(MTTR)))\nend\nfunction ùíá!(s::Server, ::Busy, ::Finish) # a finish event for a busy machine\n    pushfirst!(done, s.job)\n    s.job = 0\n    s.state = Idle()\n    event!(s.c, fun(ùíá!, s, s.state, Setup(), after, rand(EX)/5))\nend\nfunction ùíá!(s::Server, ::Failed, ::Repair) # a repair event for a failed machine\n    if s.job != 0\n        s.state = Busy()\n        event!(s.c, fun(ùíá!, s, s.state, Finish()), after, rand(EX)) # start job anew\n    else\n        s.state = Idle()\n        event!(s.c, fun(ùíá!, s, s.state, Setup(), after, rand(EX)/5))\n    end\nend","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"Out of 15 possible state-event combinations only six are defined. All others are ignored and let the current state unchanged:","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"X √ó E Setup Load Finish Fail Repair\n‚≠ë ‚Üí Idle Idle Busy - Failed -\nBusy - - Idle Failed -\nFailed - - - - Idle/Busy","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"If a Busy server gets a Fail event, it becomes Failed and cannot accept the previously scheduled Finish event. This is only defined for a Busy server and the undefined event ùíá!(s,Failed,Finish) triggers the default transition. The server will get Busy again when a Repair event arrives and then schedule a new Finish event.","category":"page"},{"location":"automata/#A-system-of-state-machines","page":"State Machines","title":"A system of state machines","text":"","category":"section"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"By creating several server instances we can represent different entities of state machines in the system. This is shown in the multi-server example.","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"A more elegant and dynamic way is to work with actors: By changing their behavior they can express state machines natively, they can have state machines as behaviors, they can create new actors dynamically ...","category":"page"},{"location":"automata/","page":"State Machines","title":"State Machines","text":"[1]: Here we include the server s as function argument. But then - since we change its state - it is Julia convention to add an exclamation mark to the function name f!.","category":"page"},{"location":"examples/multiserver/#Multi-Server-State-based","page":"Multi-Server State-based","title":"Multi-Server State-based","text":"","category":"section"},{"location":"examples/multiserver/","page":"Multi-Server State-based","title":"Multi-Server State-based","text":"Events can be expressed as state transitions mathcalf(x gamma) with x in mathcalX gamma in Gamma(x) of finite automata. The following example models 8 servers as state machines serving a queue of jobs:","category":"page"},{"location":"examples/multiserver/","page":"Multi-Server State-based","title":"Multi-Server State-based","text":"using DiscreteEvents, Printf, Random, Distributions\n\nconst p = 0.3\n\nabstract type ùëã end    # define states\nstruct Idle <: ùëã end\nstruct Busy <: ùëã end\n\nabstract type ùê∏ end    # events\nstruct Load <: ùê∏ end\nstruct Release <: ùê∏ end\nstruct Setup <: ùê∏ end\n\nmutable struct Server  # state machine body\n    id::Int\n    c::Clock\n    state::ùëã\n    job::Int\nend\n\nex = Exponential()\nqueue = Vector{Int}()\ndone  = Vector{Int}()\nBase.isready(x::Array) = !isempty(x)\n\n# transition functions\nfunction ùíá!(A::Server, ::Idle, ::Load)\n    A.job = pop!(queue)\n    A.state = Busy()\n    @printf(\"%5.2f: server %d took job %d\\n\", tau(A.c), A.id, A.job)\n    event!(A.c, fun(ùíá!, A, A.state, Release()), after, rand(ex))\nend\n\nfunction ùíá!(A::Server, ::Busy, ::Release)\n    if rand() > p\n        push!(queue, A.job)\n    else\n        pushfirst!(done, A.job)\n        @printf(\"%5.2f: server %d finished job %d\\n\", tau(A.c), A.id, A.job)\n    end\n    A.job = 0\n    A.state=Idle()\n    event!(A.c, fun(ùíá!, A, A.state, Setup()), after, rand(ex)/5)\nend\n\nùíá!(A::Server, ::Idle, ::Setup) = event!(A.c, fun(ùíá!, A, A.state, Load()), fun(isready, queue))\nùíá!(A::Server, ùë•::ùëã, Œ≥::ùê∏) = println(stderr, \"$(A.name) $(A.id) undefined transition $ùë•, $Œ≥\")\n\n# model arrivals\nfunction arrive(clk::Clock, job)\n    pushfirst!(queue, job)\n    event!(clk, fun(arrive, clk, job+1), after, rand(ex))\nend\n\n# setup simulation environment and run simulation\nRandom.seed!(123)\nc = Clock()\nA = [Server(i, c, Idle(), 0) for i ‚àà 1:8]\nfor i ‚àà shuffle(1:8)\n    event!(c, fun(ùíá!, A[i], A[i].state, Load()), fun(isready, queue))\nend\nevent!(c, fun(arrive, c, 1), after, rand(ex))\nrun!(c, 10)","category":"page"},{"location":"examples/multiserver/","page":"Multi-Server State-based","title":"Multi-Server State-based","text":"0.12: server 4 took job 1\n0.41: server 6 took job 2\n0.60: server 4 finished job 1\n0.68: server 6 finished job 2\n1.68: server 1 took job 3\n...\n9.13: server 2 took job 5\n9.28: server 3 finished job 3\n9.92: server 5 took job 9\n9.95: server 2 finished job 5\n\"run! finished with 58 clock events, 1001 sample steps, simulation time: 10.0\"","category":"page"},{"location":"examples/multiserver/","page":"Multi-Server State-based","title":"Multi-Server State-based","text":"Note that we modeled the arrivals \"event-based\" (without considering any state).","category":"page"},{"location":"examples/queue_mmc_act/#M/M/c-Activities","page":"M/M/c Activities","title":"M/M/c Activities","text":"","category":"section"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"Here we take the toy example of a multi-server M/M/c queue [1] and implement it as a sequence of server activities. We first need a server body:","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"using DiscreteEvents, Printf, Distributions, Random\n\nmutable struct Server\n    clock::Clock\n    id::Int\n    input::Channel{Int}\n    output::Channel{Int}\n    dist::Distribution\n    job::Int\nend","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"Then we implement the server activities load, serve and finish calling each other in sequence:","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"load(S::Server) = event!(S.clock, fun(serve, S), fun(isready, S.input))\n    # we check the availability of the input channel explicitly ‚Üë\n    # since we don't want to block.\n\nfunction serve(S::Server)\n    S.job = take!(S.input)\n    @printf(\"%5.3f: server %d took job %d\\n\", tau(S.clock), S.id, S.job)\n    event!(S.clock, (fun(finish, S)), after, rand(S.dist))\nend\n\nfunction finish(S::Server)\n    put!(S.output, S.job)\n    @printf(\"%5.3f: server %d finished job %d\\n\", tau(S.clock), S.id, S.job)\n    S.job=0\n    load(S)\nend","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"We model the arrivals as a function calling itself repeatedly with a time delay:","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"function arrive(c::Clock, input::Channel, num::Int, dist::Distribution)\n    @printf(\"%5.3f: customer %d arrived\\n\", tau(c), jobno[1])\n    put!(input, jobno[1])\n    jobno[1] += 1\n    if jobno[1] ‚â§ num\n        event!(c, fun(arrive, c, input, num, dist), after, rand(dist))\n      else\n        event!(c, fun(stop!, c), after, 2/Œº)\n    end\nend","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"Then we setup our constants and a simulation environment with clock, channels, servers and arrivals and run:","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"Random.seed!(8710)   # set random number seed for reproducibility\nconst N = 10                # total number of customers generated\nconst c = 2                 # number of servers\nconst Œº = 1.0 / 2           # service rate\nconst Œª = 0.9               # arrival rate\nconst M‚ÇÅ = Exponential(1/Œª) # interarrival time distribution\nconst M‚ÇÇ = Exponential(1/Œº) # service time distribution\nconst jobno = [1]           # job counter\n\n# setup the simulation environment\nclk = Clock()\ninput = Channel{Int}(32)  # create two channels\noutput = Channel{Int}(32)\n\n# create and start the servers and the arrival process\nsrv = [Server(clk,i,input,output,M‚ÇÇ,0) for i ‚àà 1:c]\nmap(s->load(s), srv)\nevent!(clk, fun(arrive, clk, input, N, M‚ÇÅ), after, rand(M‚ÇÅ))\n\nrun!(clk, 20)  # run the simulation","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"We get the following output:","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"0.123: customer 1 arrived\n0.130: server 1 took job 1\n0.226: customer 2 arrived\n0.230: server 2 took job 2\n0.546: server 1 finished job 1\n...\n9.475: customer 9 arrived\n9.530: server 2 took job 9\n10.066: server 1 finished job 8\n10.257: customer 10 arrived\n10.260: server 1 took job 10\n10.626: server 1 finished job 10\n10.739: server 2 finished job 9\n\"run! halted with 21 clock events, 1426 sample steps, simulation time: 14.26\"","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"Note that","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"the checking of the input channel in load ... switches on sampling implicitly (1426 sample steps),\nthe arrive function stops the clock","category":"page"},{"location":"examples/queue_mmc_act/","page":"M/M/c Activities","title":"M/M/c Activities","text":"[1]: see also: M/M/c queue on Wikipedia and an implementation in SimJulia.","category":"page"},{"location":"examples/queue_mmc_actor/#M/M/c-with-Actors","page":"M/M/c Actors","title":"M/M/c with Actors","text":"","category":"section"},{"location":"examples/queue_mmc_actor/","page":"M/M/c Actors","title":"M/M/c Actors","text":"Very similar to the last implementation we can implement the servers as YAActL actors. First we have to define the actor messages, the server body and a convenience function for sending a delayed message to ourselves.","category":"page"},{"location":"examples/queue_mmc_actor/","page":"M/M/c Actors","title":"M/M/c Actors","text":"using DiscreteEvents, Printf, Distributions, Random, YAActL\n\nstruct Arrive <: Message end\nstruct Finish <: Message end\n\nmutable struct Server  # state machine body\n    id::Int\n    clk::Clock\n    input::Channel\n    output::Channel\n    job::Int\n    d::Distribution\nend\n\nBase.get(clk::Clock, m::Message, after, Œît::Number) =\n    event!(clk, (fun(send!, self(), m), yield), after, Œît)","category":"page"},{"location":"examples/queue_mmc_actor/","page":"M/M/c Actors","title":"M/M/c Actors","text":"The actor realizes the same finite state machine as before by switching between two behaviors: idle and busy:","category":"page"},{"location":"examples/queue_mmc_actor/","page":"M/M/c Actors","title":"M/M/c Actors","text":"function idle(s::Server, ::Arrive)\n    if isready(s.input)\n        s.job = take!(s.input)\n        become(busy, s)\n        get(s.clk, Finish(), after, rand(s.d))\n        print(s.clk, @sprintf(\"%5.3f: server %d serving customer %d\\n\", tau(s.clk), s.id, s.job))\n    end\nend\nbusy(s::Server, ::Message) = nothing  # this is a default transition\nfunction busy(s::Server, ::Finish)\n    put!(s.output, s.job)\n    become(idle, s)\n    print(s.clk, @sprintf(\"%5.3f: server %d finished serving %d\\n\", tau(s.clk), s.id, s.job))\nend","category":"page"},{"location":"examples/queue_mmc_actor/","page":"M/M/c Actors","title":"M/M/c Actors","text":"When an idle server gets an Arrive() message, it checks its input and if there is one, it takes it and becomes busy. It schedules a Finish() message for itself after a random service time. When it arrives, it puts its job into the output and becomes idle. As you see, the code is almost plain text.","category":"page"},{"location":"examples/queue_mmc_actor/","page":"M/M/c Actors","title":"M/M/c Actors","text":"As before we need an arrival function:","category":"page"},{"location":"examples/queue_mmc_actor/","page":"M/M/c Actors","title":"M/M/c Actors","text":"function arrivals(clk::Clock, queue::Channel, lnk::Vector{Link}, N::Int, A::Distribution)\n    for i = 1:N # initialize customers\n        delay!(clk, rand(A))\n        put!(queue, i)\n        print(clk, @sprintf(\"%5.3f: customer %d arrived\\n\", tau(clk), i))\n        map(l->send!(l, Arrive()), lnk) # notify the servers\n    end\nend","category":"page"},{"location":"examples/queue_mmc_actor/","page":"M/M/c Actors","title":"M/M/c Actors","text":"We setup our environment, the actors and the arrivals process:","category":"page"},{"location":"examples/queue_mmc_actor/","page":"M/M/c Actors","title":"M/M/c Actors","text":"Random.seed!(8710)          # set random number seed for reproducibility\nconst N = 10                # total number of customers\nconst c = 2                 # number of servers\nconst Œº = 1.0 / c           # service rate\nconst Œª = 0.9               # arrival rate\nconst M‚ÇÅ = Exponential(1/Œª) # interarrival time distribution\nconst M‚ÇÇ = Exponential(1/Œº) # service time distribution\n\n# initialize simulation environment\nclock = Clock()\ninput = Channel{Int}(Inf)\noutput = Channel{Int}(Inf)\nlnk = Link[]\nfor i in 1:c   # start actors\n    s = Server(i, clock, input, output, 0, M‚ÇÇ)\n    push!(lnk, Actor(idle, s))\n    register!(clock.channels, lnk[end]) # register them to the clock\nend\nprocess!(clock, Prc(0, arrivals, input, lnk, N, M‚ÇÅ), 1)\nrun!(clock, 20)","category":"page"},{"location":"examples/queue_mmc_actor/","page":"M/M/c Actors","title":"M/M/c Actors","text":"... and get our expected output:","category":"page"},{"location":"examples/queue_mmc_actor/","page":"M/M/c Actors","title":"M/M/c Actors","text":"0.123: customer 1 arrived\n0.123: server 1 serving customer 1\n0.226: customer 2 arrived\n0.226: server 2 serving customer 2\n0.539: server 1 finished serving 1\n0.667: server 2 finished serving 2\n2.135: customer 3 arrived\n....\n9.475: server 2 serving customer 9\n10.027: server 1 finished serving 8\n10.257: customer 10 arrived\n10.257: server 1 serving customer 10\n10.624: server 1 finished serving 10\n10.734: server 2 finished serving 9\n\"run! finished with 50 clock events, 0 sample steps, simulation time: 20.0\"","category":"page"},{"location":"examples/singleserver/#Single-server","page":"Single Server","title":"Single server","text":"","category":"section"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"This example is from Choi, Kang: Modeling and Simulation of Discrete-Event Systems, p. 18. It describes a single server system. The event graph given is:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"(Image: single server)","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"Initially there are no jobs in the queue Q and the machine M is idle.\nJobs arrive with an inter-arrival-time t_aand are added to Q.\nIf M is idle, it loads a job, changes to busy and executes the job with service time t_s.\nAfter that it changes to idle and, if Q is not empty, it loads the next job.","category":"page"},{"location":"examples/singleserver/#Implementing-it","page":"Single Server","title":"Implementing it","text":"","category":"section"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"We use this simple example for illustration of how it can be modeled, simulated and analyzed using DiscreteEvents.jl. First we have to import the necessary modules:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"using DiscreteEvents, Random, Distributions, DataFrames, Plots, LaTeXStrings\npyplot()","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"We have to define some data structures, variables and a function for collecting stats:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"abstract type MState end\n\nstruct Idle <: MState end\nstruct Busy <: MState end\n\nmutable struct Job\n    no::Int64\n    ts::Float64\n    t1::Float64\n    t2::Float64\n    t3::Float64\nend\n\nmutable struct Machine\n    state::MState\n    job\nend\n\nQ = Job[]   # input queue\nS = Job[]   # stock\nM = Machine(Idle(), 0)\ndf = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])\ncount = 1\nprinting = true\n\nstats() = push!(df, (tau(), length(Q), M.state == Busy() ? 1 : 0, length(S)))","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"We can model our system activity-based und therefore implement functions for the three main activities (arrive, load, unload), which call each other during simulation.","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"We use the arrival-function for modeling arrival rate t_a with an Erlang and service time t_s with a Normal distribution. We determine the capacity of the server with a c variable such that c  1 gives us overcapacity and c = 1 means that mean service time equals mean arrival rate bart_s = bart_a.","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"function arrive(Œº, œÉ, c)\n    @assert Œº ‚â• 1 \"Œº must be ‚â• 1\"\n    ts = rand(Normal(Œº, œÉ))/c\n    job = Job(count, ts, tau(), 0, 0)\n    global count += 1\n    push!(Q, job)\n    ta = rand(Erlang())*Œº\n    event!(ùê∂, fun(arrive, Œº, œÉ, c), after, ta)  # we schedule the next arrival\n    printing ? println(tau(), \": job $(job.no) has arrived\") : nothing # tau() is the current time\n    if M.state == Idle()\n        load()\n    else\n        stats()\n    end\nend\n\nfunction load()\n    M.state = Busy()\n    M.job = popfirst!(Q)\n    M.job.t2 = tau()\n    event!(ùê∂, fun(unload), after, M.job.ts)  # we schedule the unload\n    printing ? println(tau(), \": job $(M.job.no) has been loaded\") : nothing\n    stats()\nend\n\nfunction unload()\n    M.state = Idle()\n    M.job.t3 = tau()\n    push!(S, M.job)\n    printing ? println(tau(), \": job $(M.job.no) has been finished\") : nothing\n    stats()\n    M.job = 0\n    if !isempty(Q)\n        load()\n    end\nend","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"We want to collect stats() at a sample rate of 0.1:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"sample_time!(ùê∂, 0.1)  # we determine the sample rate\nperiodic!(ùê∂, fun(stats));  # we register stats() as sampling function","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"We assume now that the capacity equals the arrivals and provide no overcapacity.  Therefore  we start with one arrival and mu = 5, sigma = 15 and c = 1 and let our system run for 30 minutes (let's assume our time unit be minutes):","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"Random.seed!(2019)\narrive(5, 1/5, 1)  # we schedule the first event\nrun!(ùê∂, 30)        # and run the simulation","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"This will give us as output:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"0: job 1 has arrived\n0: job 1 has been loaded\n4.947453062901819: job 1 has been finished\n8.515206032139384: job 2 has arrived\n8.515206032139384: job 2 has been loaded\n8.56975795472613: job 3 has arrived\n8.666481204359087: job 4 has arrived\n10.338522593089287: job 5 has arrived\n11.021099411385869: job 6 has arrived\n13.267881315092211: job 7 has arrived\n13.703372376147774: job 2 has been finished\n13.703372376147774: job 3 has been loaded\n18.726550601155594: job 3 has been finished\n18.726550601155594: job 4 has been loaded\n19.55941423914075: job 8 has arrived\n19.58302738045451: job 9 has arrived\n20.543366077813385: job 10 has arrived\n22.752994020639125: job 11 has arrived\n23.563550850400553: job 4 has been finished\n23.563550850400553: job 5 has been loaded\n23.960464112286694: job 12 has arrived\n26.84742108339802: job 13 has arrived\n28.18186102251928: job 5 has been finished\n28.18186102251928: job 6 has been loaded\n\"run! finished with 17 events, simulation time: 30.0\"","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"Using our collected data, we can plot the simulation model trajectory:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"function trajectory_plot()\n    p1 = plot(df.time, df.buffer, ylabel=\"buffer\", fill=(0,0.1,:blue))\n    p2 = plot(df.time, df.machine, ylabel=\"machine\", fill=(0,0.1,:blue))\n    p3 = plot(df.time, df.finished, xlabel=\"time [min]\", ylabel=\"stock\", fill=(0,0.1,:blue))\n    plot(p1,p2,p3, layout=(3,1), legend=false)\nend\ntrajectory_plot()","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"(Image: trajectory plot 1)","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"It seems that the queue increases over time. Thus we are interested in the behaviour of our model over a longer time. Therefore we switch off printing and continue the simulation for further 970 \"minutes\".","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"printing = false\nrun!(ùê∂, 970)        # we continue the simulation\ntrajectory_plot()","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"(Image: trajectory plot 2)","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"It seems that buffer size is increasing ever more over time. In the plot now machine load and stock aren't very instructive, so let's compare lead time W and number of jobs in the system L = textbuffer_size + textmachine_load:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"function WvsL() # get more instructive info from simulation run\n    t = [j.t1 for j ‚àà S]\n    W = [j.t3 - j.t1 for j ‚àà S]\n    ts = [j.t3 - j.t2 for j ‚àà S]\n    subs = [i ‚àà t for i ‚àà df.time]\n    L = (df.buffer + df.machine)[subs]\n    l = df.machine[subs]\n    DataFrame(time=t, load=l, W=W, L=L, ts=ts)\nend\nd = WvsL()\nplot(d.time, d.W, label=\"W [min]\", xlabel=\"time [min]\", lw=2, legend=:topleft, title=\"L and W over time\")\nplot!(d.time, d.L, label=\"L [jobs]\", lw=2)","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"(Image: L and W over time)","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"Lead time W and unfinished jobs L are clearly increasing, the system is not stationary and gets jammed over time. Let's collect some stats:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"collect_stats() =\n    (Lm = mean(d.L), Wm = mean(d.W), Œ∑ = mean(df.machine), tsm = mean(d.ts))\ncollect_stats()\n(Lm = 16.21105527638191, Wm = 78.8196419189297, Œ∑ = 0.9778719397363466, tsm = 5.003771234356064)","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"Server load of overlineŒ∑  98 is great, but the mean queue length overlineL of 16 and mean lead time overlineW  79 min are way too long for a service time of t_s  5 min. So let's analyze the dependency of mean queue length overlineL on server capacity c. For that we can manipulate the server capacity in the arrival function and collect the results in a table:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"df1 = DataFrame(c=Float64[], Lm=Float64[], Wm=Float64[], Œ∑=Float64[], tsm=Float64[])\nfor c ‚àà collect(0.97:0.01:1.7)\n    global Q = Job[]   # input queue\n    global S = Job[]   # stock\n    global M = Machine(Idle(), 0)\n    global df = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])\n    global count = 1\n\n    reset!(ùê∂)                            # reset ùê∂\n    sample_time!(ùê∂, 1)                   # set sample rate to 1\n    periodic!(ùê∂, fun(stats))   # register the stats() function for sampling\n\n    Random.seed!(2019)\n    arrive(5, 1/5, c)\n    run!(ùê∂, 1000)                        # run another simulation for 1000 \"min\"\n    global d = WvsL()\n    s = collect_stats()\n    push!(df1, (c, s.Lm, s.Wm, s.Œ∑, s.tsm))\nend","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"We can look at it in a scatter plot:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"scatter(df1.c, df1.Wm, title=L\"\\overline{W}\"*\" and \"*L\"\\overline{L}\"*\" over server capacity\",\n    xlabel=\"server capacity\", marker = (:o, 3, 0.4, :blue), label=L\"\\overline{W}\"*\" [min]\")\nscatter!(df1.c, df1.Lm, marker = (:x, 4), label=L\"\\overline{L}\"*\" [jobs]\")","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"(Image: W and L over server capacity)","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"We need to increase server capacity much in order to avoid long queues and waiting times.","category":"page"},{"location":"examples/singleserver/#How-about-Little's-law?","page":"Single Server","title":"How about Little's law?","text":"","category":"section"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"overlineW and overlineL seem to be proportional. This is stated by Little's law:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"beginequation\nL = lambdatimes W\nendequation","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"for stationary systems with lambda = arrival rate. In our case lambda = t_a = 5. Let's look at it:","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"scatter(df1.Lm, df1.Wm, xlabel=L\"\\overline{L}\"*\" [jobs]\", ylabel=L\"\\overline{W}\"*\" [min]\",\n    marker = (:o, 4, 0.4, :blue), label=\"data\", title=\"Little's law\", legend=:topleft)\nplot!(df1.Lm, df1.Lm*5, label=\"theory \"*L\"(\\overline{L}\\times 5)\")","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"(Image: Little's law)","category":"page"},{"location":"examples/singleserver/","page":"Single Server","title":"Single Server","text":"Data seems not quite to fit theory. Reason is that the system is not stationary. But for a first approach, Little's law seems not to be a bad one. In order to analyze stability and stationarity and to improve, we could refine our analysis by taking only the second half of the simulation data or by doing more simulation runs and having some more fun with DiscreteEvents.jl ...","category":"page"},{"location":"diag/#Diagnosis","page":"Diagnosis","title":"Diagnosis","text":"","category":"section"},{"location":"diag/#Clocks","page":"Diagnosis","title":"Clocks","text":"","category":"section"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"As usual in Julia you can access clock parameters by clock.parameter:","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"julia> clk                  # normally pretty printing is enabled\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Œît=0.01 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\njulia> clk.                 # with clk. + tab + tab you get the parameters\nac        end_time   evcount    id         processes  sc         scount     state      tev        time       tn         unit       Œît\njulia> clk.time             # then you can select one of them\n0.0","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"You can switch off pretty printing and then get the Julia Base.show_default display:","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"julia> DiscreteEvents.prettyClock(false)\n\njulia> clk\nClock(0, DiscreteEvents.Undefined(), 0.0, , 0.01, DiscreteEvents.ClockChannel[], DiscreteEvents.Schedule(DataStructures.PriorityQueue{DiscreteEvents.DiscreteEvent,Float64,Base.Order.ForwardOrdering}(), DiscreteEvents.DiscreteCond[], DiscreteEvents.Sample[]), Dict{Any,Prc}(), 0.01, 0.0, 0.0, 0, 0)","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"In Juno's workspace then you can access a Clock variable's structure and dig deeper into it:","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"(Image: atom workspace)","category":"page"},{"location":"diag/#Events","page":"Diagnosis","title":"Events","text":"","category":"section"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"The following clock shows that two timed events ev:2 and one conditional events cev:1 have been scheduled:","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"julia> c\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Œît=0.01 , prc:0\n  scheduled ev:2, cev:1, sampl:0","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"Registered events can be found in the scheduling structure c.sc of the clock. Better is to switch off pretty printing with DiscreteEvents.prettyClock(false) and to dive into them in the Atom workspace:","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"(Image: clock schedule)","category":"page"},{"location":"diag/#Processes","page":"Diagnosis","title":"Processes","text":"","category":"section"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"Three processes have been registered to the following clock:","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"julia> clock.processes\nDict{Any,Prc} with 3 entries:\n  0 => Prc(0, Task (runnable) @0x000000010fc82ad0, Clock 0, thrd 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Œît=0.01 , prc:3‚Ä¶\n  2 => Prc(2, Task (runnable) @0x000000010d13db10, Clock 0, thrd 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Œît=0.01 , prc:3‚Ä¶\n  1 => Prc(1, Task (runnable) @0x000000013a183190, Clock 0, thrd 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Œît=0.01 , prc:3‚Ä¶","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"We can check process 0 with","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"julia> clock.processes[0].task\nTask (runnable) @0x000000010fc82ad0","category":"page"},{"location":"diag/","page":"Diagnosis","title":"Diagnosis","text":"If the task had failed, we would get the stacktrace with that command.","category":"page"},{"location":"examples/tabletennis/#Table-tennis","page":"Table Tennis","title":"Table tennis","text":"","category":"section"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"In table tennis we have some physical constraints, standard moves and rules, but uncertainty in execution due to lack of accuray and attentiveness of the players and so on.","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"First we need to call the needed modules:","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"using DiscreteEvents, Printf\nimport DiscreteEvents.init!","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"Then we need some definitions for states, events and players:","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"abstract type PState end\nstruct Idle <: PState end\nstruct Wait <: PState end\nstruct Unalert <: PState end\n\nabstract type PEvent end\nstruct Start <: PEvent end\nstruct Serve <: PEvent end\nstruct Return <: PEvent end\nstruct Miss <: PEvent end\n\nmutable struct Player\n    name::AbstractString\n    opp::Union{Number,Player}\n    state::PState\n    accuracy::Float64\n    attentiveness::Float64\n    score::Int64\n\n    Player(name, acc, att) = new(name, 0, Idle(), acc, att, 0)\nend","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"We have to define the physical facts and a function to randomize them:","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"const dist = 3 # distance for ball to fly [m]\nconst vs   = 10 # serve velocity [m/s]\nconst vr   = 20 # return velocity [m/s]\n\nrd(s::Float64) = randn()*s + 1","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"Some functions describe the setup of players, serve and return.","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"function init!(p::Player, opp::Player)\n    p.opp = opp\n    if rand() ‚â§ p.attentiveness\n        p.state = Wait()\n    else\n        p.state = Unalert()\n    end\nend\n\nfunction serve(p::Player)\n    ts = 3 + dist*rd(0.15)/(vs*rd(0.25))\n    if (rand() ‚â§ p.accuracy) && (p.state == Wait())\n        event!(ùê∂, fun(step!, p.opp, Serve()), after, ts)\n        @printf(\"%5.2f: %s serves %s\\n\", tau()+ts, p.name, p.opp.name)\n    else\n        event!(ùê∂, fun(step!, p.opp, Miss()), after, ts)\n        @printf(\"%5.2f: %s serves and misses %s\\n\", tau()+ts, p.name, p.opp.name)\n    end\n    if rand() ‚â• p.attentiveness\n        p.state = Unalert()\n    end\nend\n\nfunction ret(p::Player)\n    tr = dist*rd(0.15)/(vr*rd(0.25))\n    if rand() ‚â§ p.accuracy\n        event!(ùê∂, fun(step!, p.opp, Return()), after, tr)\n        @printf(\"%5.2f: %s returns %s\\n\", tau()+tr, p.name, p.opp.name)\n    else\n        event!(ùê∂, fun(step!, p.opp, Miss()), after, tr)\n        @printf(\"%5.2f: %s returns and misses %s\\n\", tau()+tr, p.name, p.opp.name)\n    end\n    if rand() ‚â• p.attentiveness\n        p.state = Unalert()\n    end\nend","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"We can model the players as state machines. Their behaviour is described by the following step!-transition functions, leading to some actions and a new state.","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"\"default transition for players\"\nstep!(p::Player, q::PState, œÉ::PEvent) =\n        println(\"undefined transition for $(p.name), $q, $œÉ\")\n\n\"player p gets a start command\"\nstep!(p::Player, ::Union{Wait, Unalert}, ::Start) = serve(p)\n\n\"player p is waiting and gets served or returned\"\nstep!(p::Player, ::Wait, ::Union{Serve, Return}) = ret(p)\n\n\"player p is unalert and gets served or returned\"\nfunction step!(p::Player, ::Unalert, ::Union{Serve, Return})\n    @printf(\"%5.2f: %s looses ball\\n\", œÑ(), p.name)\n    p.opp.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"player p is waiting or unalert and gets missed\"\nfunction step!(p::Player, ::Union{Wait, Unalert}, ::Miss)\n    p.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"simplified `step!` call\"\nstep!(p::Player, œÉ::PEvent) = step!(p, p.state, œÉ)","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"We define and setup the players and give Ping the Start() command.","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"ping = Player(\"Ping\", 0.90, 0.90)\npong = Player(\"Pong\", 0.90, 0.90)\ninit!(ping, pong)\ninit!(pong, ping)\nstep!(ping, Start())","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"Finally we setup a simulation and analysis of the results:","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"Random.seed!(123)\n\nprintln(run!(ùê∂, 30))\nprintln(\"Ping scored $(ping.score)\")\nprintln(\"Pong scored $(pong.score)\")","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"If we source this code, the simulation runs:","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"julia> include(\"docs/examples/tabletennis.jl\")\n3.35: Ping serves Pong\n3.47: Pong returns and misses Ping\n6.82: Ping serves Pong\n6.96: Pong returns Ping\n7.15: Ping returns Pong\n7.28: Pong returns Ping\n7.54: Ping returns Pong\n7.80: Pong returns Ping\n7.80: Ping looses ball\n11.27: Ping serves Pong\n11.45: Pong returns Ping\n11.59: Ping returns Pong\n11.92: Pong returns Ping\n12.08: Ping returns Pong\n12.08: Pong looses ball\n15.59: Pong serves Ping\n15.59: Ping looses ball\n18.75: Ping serves Pong\n18.91: Pong returns Ping\n18.91: Ping looses ball\n22.15: Ping serves Pong\n22.30: Pong returns Ping\n22.30: Ping looses ball\n25.62: Ping serves Pong\n25.83: Pong returns Ping\n26.19: Ping returns and misses Pong\n29.50: Pong serves and misses Ping\n32.75: Ping serves Pong\nrun! finished with 47 clock events, 0 sample steps, simulation time: 30.0\nPing scored 3\nPong scored 5","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"Finally we reset the clock for further simulations:","category":"page"},{"location":"examples/tabletennis/","page":"Table Tennis","title":"Table Tennis","text":"julia> reset!(ùê∂)\nclock reset to t‚ÇÄ=0, sampling rate Œît=0.","category":"page"},{"location":"clocks/#Clocks","page":"Clocks","title":"Clocks","text":"","category":"section"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"We think of a clock as a device to measure time   [1]. An event sequence S = e_1 e_2  e_n has measured times t_1  t_2    t_n. From that order we draw inferences about causality.","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"A Clock in DiscreteEvents schedules events and triggers them at given times or under given conditions. It doesn't measure, it represents time. We can create a clock, run it for a while, stop time, step through time, skip from event to event, change event sequences ‚Ä¶ With it we can create, model or simulate discrete event systems (DES).","category":"page"},{"location":"clocks/#Virtual-clocks","page":"Clocks","title":"Virtual clocks","text":"","category":"section"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"A virtual clock is not constrained by physical time. It doesn't wait a physical time period for the next event to occur, but jumps right to it. It executes an event sequence as fast as possible.","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"using DiscreteEvents\nclk = Clock()","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"We created a new clock, running on thread 1, having time t=00, a sampling rate of Œît=001, no registered processes, no scheduled events, conditional events or sampling actions.","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"run!(clk, 10)","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"If we run the clock for a duration Œît=10, it jumps immediately ahead since it has nothing to do.","category":"page"},{"location":"clocks/#Time-units","page":"Clocks","title":"Time units","text":"","category":"section"},{"location":"clocks/#Real-time-clocks","page":"Clocks","title":"Real time clocks","text":"","category":"section"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"A real time clock RTClock is bound to the computer's physical clock and measures time in seconds s. We create and start it with createRTClock","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"rtc = createRTClock(0.01, 99)","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"Here we have created a real time clock with id=99 on thread 8. It has a clock period of T=0.01 s and synchronizes at that resolution with the system clock running in nano-seconds. When the start message was created, the clock had just advanced 0.0001193 s. When we query its time thereafter, it returns the time in seconds passed since startup:","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"sleep(1) # hide\ntau(rtc)         # query time\nsleep(1) # hide\nrtc.time         # synonymous way to get time","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"We can schedule events to real time clocks as to virtual clocks and they will execute at their due physical time.","category":"page"},{"location":"clocks/#clock_concurrency","page":"Clocks","title":"Clock concurrency","text":"","category":"section"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"DiscreteEvents can represent entities in DES as tasks (e.g. processes, actors) running concurrently to the clock. We want them to coordinate with the clock and not to go out of time.","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"The user must take two precautions:","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"Actors must register (push!) their message channels to the clock and the clock will only proceed to the next event if all registered channels are empty.\nTasks use now! for IO-operations or print via the clock.","category":"page"},{"location":"clocks/#Parallel-clocks","page":"Clocks","title":"Parallel clocks","text":"","category":"section"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"With multithreading and tasks running in parallel we want to maintain the order of cause and effect and to avoid than an event scheduled for a time t_i+1 executes on a parallel thread before an event scheduled for t_i completes.","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"In parallel simulations we take at least four steps in order to limit time skew and event disorder:","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"With thread local clocks we maintain a local order of events on each thread and\nsynchronize the local clocks often with the global clock on thread 1.\nUsers keep associated entities and events (subsystems) together on threads and\ntake care that distributed DES subsystems are sufficiently decoupled.","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"This is described at greater length in distributed simulations. Here we illustrate how to create and access parallel clocks:","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"pc = PClock()           # create a master clock with parallel clocks\npc2 = pclock(pc, 2)     # access the active clock on thread 2\npc2.clock               # access the parallel clock on thread 2\npc2.clock.ac[]          # back to the active clock 2\npc2.clock.ac[].master[] # back to master on thread 1","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"Note that the master clock is a shared variable of active clock 2. This is an intermediate solution and will change soon. Otherwise the interaction between the global (master) clock on thread 1 and the parallel local clocks is happening via message channels. Parallel clocks have message channels to master but not to each other.","category":"page"},{"location":"clocks/#Clock-commands","page":"Clocks","title":"Clock commands","text":"","category":"section"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"[1]: In essence we count the number of naturally occurring periodic events to measure time: the revolutions of a moon or planet, our heart beats, the swings of a pendulum ‚Ä¶ or more advanced measurement methods.","category":"page"},{"location":"actions/#Actions","page":"Actions","title":"Actions","text":"","category":"section"},{"location":"actions/","page":"Actions","title":"Actions","text":"We consider time as given or measured by a clock C. Furthermore we characterize a discrete event system (DES) by","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"beginarraylll\n  mathcalX=x_i x_j  x_n  textrma discrete set of states \n  mathcalE=alpha beta gamma   textrma countable set of events eventually causing state transitions\nendarray","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"In an observed event sequence e_1 e_2 e_3  each event e_i in mathcalE is associated with a time t_i [1]. We can write that as a sequence of tuples:","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"(e_1t_1)(e_2t_2)(e_3t_3)hspace1emhspace1em (e_nt_n)","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"In DiscreteEvents we want to represent an event always as that tuple (e_it_i). For representing e_i computationally, we introduce the term action [2]. An Action is a Julia expression, a function object or a tuple of them, which will be executed at a given time:","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"julia> using DiscreteEvents\n\njulia> :(a+1) isa Action     # :(a+1) can be executed later\ntrue\n\njulia> println isa Action    # a function object can be called later\ntrue\n\njulia> ()->println()         # we create an anyonymous function\n#9 (generic function with 1 method)\n\njulia> ans isa Action        # this too is an action\ntrue\n\njulia> (:(a+1), println) isa Action  # a tuple of actions too is an action\ntrue","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"Simple expressions like a+1 or function calls like println() are not Actions since they get executed immediately and cannot be stored for later execution.","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"note: Use functions!\nUse functions instead of expressions because it is much faster. If you use expressions, you will get a one-time warning.","category":"page"},{"location":"actions/#Fun-with-functions","page":"Actions","title":"Fun with functions","text":"","category":"section"},{"location":"actions/","page":"Actions","title":"Actions","text":"To use or modify data we call a function f on parameters x, y and z as f(x,y,z). But this executes it immediately. If we want to execute f(x,y,z) later, we can wrap it now in a function, an anonymous function or in a fun function closure.","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"julia> f(x,y,z) = x+y+z            # define a function\nf (generic function with 1 method)\n\njulia> x=1; y=1; z=1;              # define variables\n\njulia> f(x,y,z) isa Action         # f(x,y,z) is not an Action\nfalse\n\njulia> f(x,y,z)\n3\n\njulia> f isa Action                # this is an Action, but looses the parameters\ntrue\n\njulia> g() = f(x,y,z)              # capture f(x,y,z) in g\ng (generic function with 1 method)\n\njulia> g isa Action\ntrue\n\njulia> g()\n3\n\njulia> h = (()->f(x,y,z))          # use an anonymous function\n#11 (generic function with 1 method)\n\njulia> h()\n3\n\njulia> i = fun(f,x,y,z)            # use a fun\n#7 (generic function with 1 method)\n\njulia> i()\n3\n\njulia> i isa Action\ntrue\n\njulia> fun(f,x,y, fun(f,x,y,z))()\n5\n","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"funs are executable and can be nested. Thus they provide a structure to store functions and their variables for later execution.","category":"page"},{"location":"actions/#Access-data","page":"Actions","title":"Access data","text":"","category":"section"},{"location":"actions/","page":"Actions","title":"Actions","text":"If you want to change data in an Action, the simplest way is to work with mutable values (like Arrays):","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"julia> mutable struct Counter       # define a counter type\n           x::Int\n       end\n\njulia> cc = Counter(0)                # setup a counter\nCounter(0)\n\njulia> g(ctr::Counter) = ctr.x += 1   # a function to increment a counter\ng (generic function with 1 method)\n\njulia> gg = fun(g, cc)                # put it in a fun closure with a counter variable\n#8 (generic function with 1 method)\n\njulia> gg()                           # execute it\n1\n\njulia> cc                             # the counter variable has increased\nCounter(1)","category":"page"},{"location":"actions/#Global-variables","page":"Actions","title":"Global variables","text":"","category":"section"},{"location":"actions/","page":"Actions","title":"Actions","text":"To make Actions work with global variables, you must be careful to access their current value and use the global keyword to change them.","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"julia> a = 1; b = 2; c = 3;         # create some global data\n\njulia> f1(x, y, z) = x^y + z        # define a function\nf (generic function with 1 method)\n\njulia> ff = fun(f1, a, b, c)        # create a function closure with captured data\n#8 (generic function with 1 method)","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"ff captures the values of a, b and c when it is created. But those may change until execution. You can as well capture the current values at execution time:","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"julia> gg = fun(f1, ()->a, ()->b, ()->c)  # capture the data at execution time\n#8 (generic function with 1 method)\n\njulia> gg()                         # execute the closure\n4\n\njulia> a = 2                        # change one of the data values\n2\n\njulia> gg()                         # ff now captures the changed data\n7","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"Also if you pass a function call as argument to a fun, it gets executed immediately and you must hide it from immediate execution if you want to have it executed at event time.","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"You can also pass the data symbolically to the fun closure:","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"julia> hh = fun(f1, :a, :b, :c)\n#8 (generic function with 1 method)\n\njulia> hh()\n‚îå Warning: Evaluating expressions is slow, use functions instead\n‚îî @ DiscreteEvents ~/.julia/packages/DiscreteEvents/vyBMT/src/fclosure.jl:37\n7\n\njulia> a = 3\n3\n\njulia> hh()\n12","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"Note that you got a warning because this is slow and thus not recommended.","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"[1]: We follow Cassandras: Discrete Event Systems, 2008, p. 27 and don't attempt to define what an \"event\" is. \"We only wish to emphasize that an event should be thought of as occurring instantaneously and eventually causing transitions from one state value to another.\"","category":"page"},{"location":"actions/","page":"Actions","title":"Actions","text":"[2]: This means simply a computational action. It does not have to be a state transition of the represented system. It could be also a check if an event is feasible.","category":"page"},{"location":"processes/#Processes","page":"Processes","title":"Processes","text":"","category":"section"},{"location":"processes/","page":"Processes","title":"Processes","text":"Often in discrete event systems (DES) we find typical sequences of events S_i = e_i e_j e_k  e_m repeated over and over and carried out asynchronously by similar agents. For example servers in a data center may","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"take a job from an input queue,\nprocess it for a service time,\nrelease the job and put it into an output queue.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"Those typical event sequences are called processes [1]. If processes interact, their event sequences overlap and generate the event sequence S=e_1e_2e_3  e_n of the entire system.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"Processes in DiscreteEvents","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"use functions to describe a characteristic sequence S_i and\nrun as asynchronous Julia tasks.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"They keep their own data, states and code in their function body.","category":"page"},{"location":"processes/#Syntax","page":"Processes","title":"Syntax","text":"","category":"section"},{"location":"processes/","page":"Processes","title":"Processes","text":"Processes execute Julia code, wait or delay on the clock and are suspended and reactivated by Julia's scheduler according to available resources. For operations regarding time, IO and resources they use:","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"delay!:  suspend and get reactivated (by the clock) at/after a given time,\nwait!:  suspend and get reactivated after a given condition becomes true,\nnow!:  transfer IO-operations to the clock,\ntake!: take an item from a channel or block until it becomes available,\nput!: put something into a channel or block if it is full until it becomes available.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"The first three commands: delay!, wait! and now! create events on the clock's event scheduler, take! and put! are handled directly by the Julia scheduler. All blocking commands should only be used in processes (asynchronous tasks) and never within the main program or in the Julia REPL [2].","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"The following two functions define processes:","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"# describe the server process\nfunction server(clk::Clock, id::Int, input::Channel, output::Channel, service_dist::Distribution)\n    job = take!(input)\n    print(clk, @sprintf(\"%5.3f: server %d serving customer %d\\n\", tau(clk), id, job))\n    delay!(clk, rand(service_dist))\n    print(clk, @sprintf(\"%5.3f: server %d finished serving %d\\n\", tau(clk), id, job))\n    put!(output, job)\nend\n\n# describe the arrivals process\nfunction arrivals(clk::Clock, queue::Channel, num_customers::Int, arrival_dist::Distribution)\n    for i = 1:num_customers # initialize customers\n        delay!(clk, rand(arrival_dist))\n        put!(queue, i)\n        print(clk, @sprintf(\"%5.3f: customer %d arrived\\n\", tau(clk), i))\n    end\nend","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"note: Rules for processes\nto run as processes, functions must have a Clock variable as their first argument,\nprocesses (or asynchronous tasks in general) must print via the clock in order to avoid clock concurrency.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"We can start multiple instances of processes representing e.g. multiple servers and different arrival processes.","category":"page"},{"location":"processes/#Startup","page":"Processes","title":"Startup","text":"","category":"section"},{"location":"processes/","page":"Processes","title":"Processes","text":"To register functions as processes to the clock and start them we use:","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"Prc: prepare a function to run as a process,\nprocess!: register a Prc to a clock, start it in a loop as an asynchronous task and return its id.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"The following code example starts our processes (we assume the variables to be defined before):","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"for i in 1:num_servers  # start multiple server processes\n    process!(clock, Prc(i, server, i, input, output, service_dist))\nend\nprocess!(clock, Prc(0, arrivals, input, num_customers, arrival_dist), 1)","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"The server processes run their function body in an infinite loop (default) while the arrivals process runs it only once and then terminates. The server processes wait for jobs in their input channels and the arrivals process waits for the clock to tick. If we start the clock, the processes begin to interact: customers are produced by the arrivals process, the servers then serve them ‚Ä¶","category":"page"},{"location":"processes/#Limitations","page":"Processes","title":"Limitations","text":"","category":"section"},{"location":"processes/","page":"Processes","title":"Processes","text":"Interacting sequential processes depend on \"a rendezvous between the processes involved in sending and receiving the message, i.e. the sender cannot transmit a message until the receiver is ready to accept it\". [3]","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"If typical event sequences S_i (e.g. waiting for a resource or time delays) are interrupted by stochastic events (e.g. server breakdowns, customers reneging ‚Ä¶), the processes are not ready and must use exception handling to tackle them. This means that we have to treat natural occurrences in a stochastic DES as errors in our program.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"This a severe limitation of \"processes\" as used in simulations. If we have to handle a lot of such interrupting events, things are getting  complicated. This is a barrier to represent more complex systems with sequential processes.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"[1]: see: Banks, Carson, Nelson, Nicol: Discrete-Event System Simulation, 4th ed, 2005, p. 74-77","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"[2]: If you want to use take! or put! on channels inside the main program, make sure that they are available (with isready(ch) or length(ch.data) < ch.sz_max) before calling them in order to avoid blocking.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"[3]: see: Communicating Sequential Processes (CSP) on Wikipedia.","category":"page"},{"location":"activities/#Activities","page":"Activities","title":"Activities","text":"","category":"section"},{"location":"activities/","page":"Activities","title":"Activities","text":"We think of an activity as taking some time while an event is instantaneous. One useful definition for activity is:","category":"page"},{"location":"activities/","page":"Activities","title":"Activities","text":"A pair of events, one initiating and the other completing an operation that transforms the state of an entity. Time elapses in an activity. [1]","category":"page"},{"location":"activities/","page":"Activities","title":"Activities","text":"Usually there are different entities in a DES. In a timed sequence of events","category":"page"},{"location":"activities/","page":"Activities","title":"Activities","text":"(e_1t_1)(e_2t_2)(e_3t_3)hspace1emhspace1em (e_nt_n)","category":"page"},{"location":"activities/","page":"Activities","title":"Activities","text":"an activity may span two or more events in a system. E.g. a server starts to serve a customer at a given time. This activity takes a certain interval in time. Within that interval other customers may arrive or leave or other servers may proceed in their work.","category":"page"},{"location":"activities/","page":"Activities","title":"Activities","text":"For certain problems it is useful to describe a DES as a sequence of activities. The activity based approach models a DES as sequences of activities of multiple entities overlapping each other in time. For practical purposes an activity is a function combining","category":"page"},{"location":"activities/","page":"Activities","title":"Activities","text":"some operations to describe the activity with\nan event to call the next activity.","category":"page"},{"location":"activities/","page":"Activities","title":"Activities","text":"This is still a form of event scheduling. The following code snippet implements three activities of a server:","category":"page"},{"location":"activities/","page":"Activities","title":"Activities","text":"load(S::Server) = event!(S.clock, fun(serve, S), fun(isready, S.input))\n\nfunction serve(S::Server)\n    S.job = take!(S.input)\n    @printf(\"%5.3f: server %d took job %d\\n\", tau(S.clock), S.id, S.job)\n    event!(S.clock, (fun(finish, S)), after, rand(S.dist))\nend\n\nfunction finish(S::Server)\n    put!(S.output, S.job)\n    @printf(\"%5.3f: server %d finished job %d\\n\", tau(S.clock), S.id, S.job)\n    S.job=0\n    load(S)\nend","category":"page"},{"location":"activities/","page":"Activities","title":"Activities","text":"If in our example the boss ‚Äì or another customer or a computer failure ... ‚Äì interrupts the serve activity, we are in trouble - as in life - and would have to implement a mechanism for handling such exceptions.","category":"page"},{"location":"activities/","page":"Activities","title":"Activities","text":"[1]: George S. Fishman: Discrete-Event Simulation ‚Äì Modeling, Programming, and Analysis, Springer, 2001, p 39","category":"page"},{"location":"sampling/#Sampling","page":"Sampling","title":"Sampling","text":"","category":"section"},{"location":"sampling/","page":"Sampling","title":"Sampling","text":"The simplest mechanism for generating discrete events is to have a clock clk execute an action ùú∏ periodically. We can generate periodic events in various ways:","category":"page"},{"location":"sampling/","page":"Sampling","title":"Sampling","text":"sampling events with periodic!(clk, ùú∏, Œît) are executed at the clock sample rate Œît,\nrepeating events with event!(clk, ùú∏, every, Œît) are executed every given interval Œît,\nconditional events with event!(clk, ùùÉ, ùú∏) check the condition ùú∏ at the clock's sample rate Œît until it returns true. Then ùùÉ is executed.","category":"page"},{"location":"sampling/","page":"Sampling","title":"Sampling","text":"Thus we can model periodic events but no stochastic event sequences. Sampling is useful if we want to model repeated or periodic events interacting with a DES, check conditions, trace or visualize the system periodically.","category":"page"},{"location":"sampling/","page":"Sampling","title":"Sampling","text":"Sampling introduces a time uncertainty into simulations since it triggers changes, takes measurements or checks for conditions only at a given time interval Œît.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the companion site to DiscreteEvents.jl. It is a documentation in development, still not and possibly never perfect.","category":"page"},{"location":"#Quick-Intro","page":"Home","title":"Quick Intro","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"With DiscreteEvents you can schedule and run Julia functions and expressions as events on a timeline represented by a clock:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DiscreteEvents, Distributions, Random\n\nRandom.seed!(123)\nex = Exponential()\n\nchit(c) = (print(\".\"), event!(c, fun(chat, c), after, rand(ex)))\nchat(c) = (print(\":\"), event!(c, fun(chit, c), after, rand(ex)))\n\nc = Clock()\nevent!(c, fun(chit, c), after, rand(ex))\nevent!(c, println, at, 10)\nrun!(c, 10)","category":"page"},{"location":"","page":"Home","title":"Home","text":".:.:.:.:.:.:.:.:.\n\"run! finished with 18 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Paul Bayer License: MIT","category":"page"}]
}
